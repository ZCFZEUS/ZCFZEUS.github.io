[{"content":"概述 TIM 定时器是 STM32 中功能最强大、结构最复杂的一个外设。\n其基本功能是可以从名字的得出“定时”，定时器可以对输入的时钟进行计数，并且在计数值达到设定值时出发中断。其内部拥有 16 位计数器、预分频器、自动重装寄存器的时基单元，在 72MHz 计数时种下可以实现最大 59.65S 定时。\n除了基本的定时中断功能，其还包含内外时钟源选择、输入捕获、输入比较、编码器接口、主从触发等多种功能，定时器根据复杂度和应用场景分为了高级定时器、通用定时器、基本定时器三种类型：\nSTM32F103C8T6定时器资源：TIM1、TIM2、TIM3、TIM4\n时基单元 时基单元式定时器的根本，无论是高级定时器、通用定时器还是基本定时器都是通过时基单元来实现定时的功能。其结构图如下图所示：\n时基单元是由 PSC 预分频器、CNT 计数器、自动重装载寄存器构成的计数计时电路，这三个寄存器均为 16 位寄存器。时钟给时基单元输入一个时钟信号，该时钟信号经过 PSC 预分屏器产生时钟信号，CNT 计数器对该时钟信号进行计数并与自动重装载寄存器内存放的目标计数值比较，当计数值与目标值相等时 CNT 计数器会自动清零并产生一个更新中断或更新事件（注此处举例说明 CNT 计数器的计数模式为向上计数模式）\n时基单元功能解析： 1 PSC 预分频器：对输入的系统频率提前进行一个分频操作。当 PSC 为 0 时，对输入信号不分频（也可称之为 1 分频）输入信号=72MHz/(0+1)=72MHz，此时输入信号频率为72MHz。当 PSC=1 时（2 分频），输入信号=72MHz/（1+1）=36MHz。当 PSC=3 时，输入信号=72MHz/（2+1）=16MHz。以此类推\u0026hellip;注 PSC 为 16 位寄存器，最大分频系数可为 65535，即 65536 分频。此寄存器具有缓冲，可以在运行的过程中改变它的数值，新的预分频值将在下一个更新时间时起作用。\n2 CNT 计数器：对预分频后的时钟信号进行计数（基本计数器的）计数的模式分为：向上计数模式、向下计数模式、中央对齐模式三种模式。\n3 自动重装寄存器：存储设定的计数目标值。\nCNT 计数器的技术模式解析：\n1 向上计数模式：计数器从 0 开始，向上自增，记到重装值，清零同时申请中断并开始下一轮的计数，依此循环（此模式为最常用模式）\n2 向下计数模式：计数器从重装值开始，向下自减，直至减至 0 复位至重装值并申请93中断，重新开始下一轮的计数，依此循环\n3 中央对齐模式：计数器从 0 开始，先向上自增直至重装值并申请中断，再向下自减，减至 0 并再申请中断，依此循环\n基本定时器 基本定时器拥有定时功能以及主从式触发 DAC 功能\n内部时钟（单片机主频 72MHz）给基本定时器的时基单元输入一个时钟信号，CNT 计数器对经过PSC分频器后的输入信号从0开始向上计数（注：基本定时器只支持向上计数模式），直至自增到设定的计数目标，此时会产生一个更新中断 UI 或更新事件 U。若产生的是更新中断，则该信号会通往配置好的 NVIC 定时器通道，此时 CPU 将会响应定时器的更新中断。若产生的是更新事件，更新事件不会出发中断，但可以触发内部其他电路的工作。注：基本定时器只支持内部时钟作为时基单元的输入信号源。\n通用定时器 通用定时器拥有基本定时器全部功能，并额外具有内外时钟源选择、输入捕获、输出比较、编码器接口、主从触发模式等功能。其内部基本结构可分为 4 部分，如下所示：\n1 内外时钟源选择部分，见上图灰色方框\n2 时基单元，见上图红色方框\n3 输入捕获部分，见上图蓝色方框\n4 输出比较部分，见上图绿色方框\n通用定时器内外时钟源选择 不同于基本定时器的时钟源只支持内部时钟（单片机主频 72MHz），通用定时器和高 级定时器的时钟源可以选择内部时钟（单片机主频 72MHz）以及外部时钟源，其中内部时钟模式为日常开发最常用的模式，通用定时器的内部时钟输入原理与基本定时器的一致，其外部时钟输入模式则可分为 ETR 引脚输入，ITRx 其他定时器、Tlx 捕获通道边沿模式、Tlx 捕获通道四种输入模式。一般情况下外部时钟输入只会用到 ETR 引脚输入模式，其他三种模式均为某些特殊应用场景设计。定时中断基本结构如下图所示： ①第一部分是来自于 TIMx_ETR（PA0）引脚上的外部时钟，外部通过该引脚输入一个 时钟信号，此时钟信号经过一些配置（机性选择、边沿检测、预分频）及滤波后（外部输入信号一般均带有毛刺信号，因此需要经过滤波电路）后有两条分支路径 ETRF 路径和 TRGI路径。经过 ETRF 路径后就可选择作为时基单元的时钟。（在 STM32 中，这一路路径被称为“外部时钟模式 2”）\n经过 TRGI 路径主要作为触发输入使用，该触发输入可以触发定时器的从模式。当触发输入作为外部时钟使用时，就作为时基单元的时钟，（在 STM32 中，这一路径被称为“外部时钟模式 1”）\n②第二部分（其他定时器输入）来自于 ITR 信号，ITR 信号（又分为 ITR0、ITR1、ITR2、ITR3 三个输入信号）的时钟是来自于其他定时器，时钟的触发控制器有一引脚 TRGO，该引脚可连接至其他定时器，当其连接至其他定时器时，其他定时器的输出就可作为 ITR 的输入，以此来达到定时器级联的功能。TRGO 连接其他定时器作为 ITR 输入时，ITR0、ITR1、ITR2、ITR3 的连接方式如下表所示：\nTIM3 与 TIM2 级联举例说明：初始化 TIM2、TIM3，将 TIM3 设置为主模式并将其更新时间映射到 TRGO 上，此时 TRGO 将会连接至 TIM2 的 ITR2。TIM3 的更新事件信号将作为定时器 2 的时钟输入信号。以此实现 TIM3、TIM2 的定时器级联。如下图所示：\n③第三部分来自于 TI1F_ED，TI1F_ED 连接至输入捕获单元的 TIMx_CH1，即外界可通过 TIMx_CH1 引脚输入时钟信号。注：此路输入的时钟，上升沿及下降沿均有效。（TI1F_ED中 ED 意为 Edge，中文边沿的意思。代表着信号上升沿及下降沿均有效）。如下图所示：\n第四部分来自于 TI1FP1、TI2FP2 两条同路。第一条 TI1FP1 连接至输入捕获单元的TIMx_CH1 通道，即外界可以通过 TIMx_CH1 引脚输入时钟信号。第二条 TI2FP2 连接至输入捕获单元的 TIMx_CH2 通道，即外界可以通过 TIMx_CH2 引脚输入时钟信号\n高级定时器 高级定时器拥有通用定时器的全部功能，并额外拥有重读计数器、死区生成、互补输出、刹车输入等功能。其内部结构与通用定时器基本一致，只是在其结构上增加了三个部分。如下图所示：\n① 重复次数计数器（16 位）：在通用定时器中，CNT 计数器从 0 开始对时钟信号进行计数。当计数值累加到目标计数值后会产生一个更新中断或更新事件，这一个过程我们称为 1 个定时周期。在高级定时器中。重复此时计数器的作用是可改变产生更新中断或更新事件的周期，即在通用定时器中，经过 1 个定时周期产生一个更新中断或更新事件，在高级定时器中，可设定经过 n 个定时周期产生一个更新中断或更新事件，相当于一个分频器 ② DTG 寄存器及互补通道：增加了 DTG 寄存器和互补通道，高级定时器即可实现死区生成、互补输出的功能 ③ TIMx_BKIN 刹车输入：该功能是给电机驱动提供安全保障的，当 TIMx_BKIN 产生刹车信号或内部时钟失效故障时，控制电路会自动切断电机输出，防止以外发生\n定时中断解析 定时中断基本结构 预分频器时序 计数器时序 计数器无预装时序 计数器有预装时序 时钟树 内部时钟定时中断程序解析 基本步骤 ① 使能 TIM2 时钟。\n② 设置为内部时钟模式。\n③ 配置 TIM2 定时器，主要关注 TIM_CounterMode、TIM_Period、TIM_Prescaler 即计数模式、目标计数值、PSC 分频因子（此定时器定时时间为 T=1/(72M/(7200)/100=10us)）。\n④ 初始化 TIM2 定时器\n⑤ 配置中断并使能中断\n⑥ 配置 NVIC\n⑦ 使能定时器\n相关函数 编程实例 定时器定时中断 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 //Timer.c #include \u0026#34;stm32f10x.h\u0026#34; // Device header /** * 函 数：定时中断初始化 * 参 数：无 * 返 回 值：无 */ void Timer_Init(void) { /*开启时钟*/ RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);\t//开启TIM2的时钟 /*配置时钟源*/ TIM_InternalClockConfig(TIM2);\t//选择TIM2为内部时钟，若不调用此函数，TIM默认也为内部时钟 /*时基单元初始化*/ TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;\t//定义结构体变量 TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;\t//时钟分频，选择不分频，此参数用于配置滤波器时钟，不影响时基单元功能 TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;\t//计数器模式，选择向上计数 TIM_TimeBaseInitStructure.TIM_Period = 10000 - 1;\t//计数周期，即ARR的值 TIM_TimeBaseInitStructure.TIM_Prescaler = 7200 - 1;\t//预分频器，即PSC的值 TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0;\t//重复计数器，高级定时器才会用到 TIM_TimeBaseInit(TIM2, \u0026amp;TIM_TimeBaseInitStructure);\t//将结构体变量交给TIM_TimeBaseInit，配置TIM2的时基单元\t/*中断输出配置*/ TIM_ClearFlag(TIM2, TIM_FLAG_Update);\t//清除定时器更新标志位 //TIM_TimeBaseInit函数末尾，手动产生了更新事件 //若不清除此标志位，则开启中断后，会立刻进入一次中断 //如果不介意此问题，则不清除此标志位也可 TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE);\t//开启TIM2的更新中断 /*NVIC中断分组*/ NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);\t//配置NVIC为分组2 //即抢占优先级范围：0~3，响应优先级范围：0~3 //此分组配置在整个工程中仅需调用一次 //若有多个中断，可以把此代码放在main函数内，while循环之前 //若调用多次配置分组的代码，则后执行的配置会覆盖先执行的配置 /*NVIC配置*/ NVIC_InitTypeDef NVIC_InitStructure;\t//定义结构体变量 NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;\t//选择配置NVIC的TIM2线 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;\t//指定NVIC线路使能 NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;\t//指定NVIC线路的抢占优先级为2 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;\t//指定NVIC线路的响应优先级为1 NVIC_Init(\u0026amp;NVIC_InitStructure);\t//将结构体变量交给NVIC_Init，配置NVIC外设 /*TIM使能*/ TIM_Cmd(TIM2, ENABLE);\t//使能TIM2，定时器开始运行 } /* 定时器中断函数，可以复制到使用它的地方 void TIM2_IRQHandler(void) { if (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET) { TIM_ClearITPendingBit(TIM2, TIM_IT_Update); } } */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 //main.c #include \u0026#34;stm32f10x.h\u0026#34; // Device header #include \u0026#34;Delay.h\u0026#34; #include \u0026#34;OLED.h\u0026#34; #include \u0026#34;Timer.h\u0026#34; uint16_t Num;\t//定义在定时器中断里自增的变量 int main(void) { /*模块初始化*/ OLED_Init();\t//OLED初始化 Timer_Init();\t//定时中断初始化 /*显示静态字符串*/ OLED_ShowString(1, 1, \u0026#34;Num:\u0026#34;);\t//1行1列显示字符串Num: while (1) { OLED_ShowNum(1, 5, Num, 5);\t//不断刷新显示Num变量 } } /** * 函 数：TIM2中断函数 * 参 数：无 * 返 回 值：无 * 注意事项：此函数为中断函数，无需调用，中断触发后自动执行 * 函数名为预留的指定名称，可以从启动文件复制 * 请确保函数名正确，不能有任何差异，否则中断函数将不能进入 */ void TIM2_IRQHandler(void) { if (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET)\t//判断是否是TIM2的更新事件触发的中断 { Num ++;\t//Num变量自增，用于测试定时中断 TIM_ClearITPendingBit(TIM2, TIM_IT_Update);\t//清除TIM2更新事件的中断标志位 //中断标志位必须清除 //否则中断将连续不断地触发，导致主程序卡死 } } 外部时钟定时中断程序解析 基本步骤 步骤总结： 1 使能 TIM2 时钟\n2 使能外部输入引脚时钟\n3 配置外部输入引脚并使能\n4 设置为外部时钟输入模式 2. 5 配置 TIM2 定时器，主要关注TIM_CounterMode、TIM_Period、TIM_Prescaler 即计数模式、目标计数值、PSC 分频因子（此定时器定时时间为 T=1/(72M/(7200)/100=10us)） 6 初始化 TIM2 定时器\n7 配置中断并使能中断\n8 配置 NVIC\n9 使能定时器\n编程实例 定时器外部时钟 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 //Timer.c #include \u0026#34;stm32f10x.h\u0026#34; // Device header /** * 函 数：定时中断初始化 * 参 数：无 * 返 回 值：无 * 注意事项：此函数配置为外部时钟，定时器相当于计数器 */ void Timer_Init(void) { /*开启时钟*/ RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);\t//开启TIM2的时钟 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);\t//开启GPIOA的时钟 /*GPIO初始化*/ GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, \u0026amp;GPIO_InitStructure);\t//将PA0引脚初始化为上拉输入 /*外部时钟配置*/ TIM_ETRClockMode2Config(TIM2, TIM_ExtTRGPSC_OFF, TIM_ExtTRGPolarity_NonInverted, 0x0F); //选择外部时钟模式2，时钟从TIM_ETR引脚输入 //注意TIM2的ETR引脚固定为PA0，无法随意更改 //最后一个滤波器参数加到最大0x0F，可滤除时钟信号抖动 /*时基单元初始化*/ TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;\t//定义结构体变量 TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;\t//时钟分频，选择不分频，此参数用于配置滤波器时钟，不影响时基单元功能 TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;\t//计数器模式，选择向上计数 TIM_TimeBaseInitStructure.TIM_Period = 10 - 1;\t//计数周期，即ARR的值 TIM_TimeBaseInitStructure.TIM_Prescaler = 1 - 1;\t//预分频器，即PSC的值 TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0;\t//重复计数器，高级定时器才会用到 TIM_TimeBaseInit(TIM2, \u0026amp;TIM_TimeBaseInitStructure);\t//将结构体变量交给TIM_TimeBaseInit，配置TIM2的时基单元\t/*中断输出配置*/ TIM_ClearFlag(TIM2, TIM_FLAG_Update);\t//清除定时器更新标志位 //TIM_TimeBaseInit函数末尾，手动产生了更新事件 //若不清除此标志位，则开启中断后，会立刻进入一次中断 //如果不介意此问题，则不清除此标志位也可 TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE);\t//开启TIM2的更新中断 /*NVIC中断分组*/ NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);\t//配置NVIC为分组2 //即抢占优先级范围：0~3，响应优先级范围：0~3 //此分组配置在整个工程中仅需调用一次 //若有多个中断，可以把此代码放在main函数内，while循环之前 //若调用多次配置分组的代码，则后执行的配置会覆盖先执行的配置 /*NVIC配置*/ NVIC_InitTypeDef NVIC_InitStructure;\t//定义结构体变量 NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;\t//选择配置NVIC的TIM2线 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;\t//指定NVIC线路使能 NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;\t//指定NVIC线路的抢占优先级为2 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;\t//指定NVIC线路的响应优先级为1 NVIC_Init(\u0026amp;NVIC_InitStructure);\t//将结构体变量交给NVIC_Init，配置NVIC外设 /*TIM使能*/ TIM_Cmd(TIM2, ENABLE);\t//使能TIM2，定时器开始运行 } /** * 函 数：返回定时器CNT的值 * 参 数：无 * 返 回 值：定时器CNT的值，范围：0~65535 */ uint16_t Timer_GetCounter(void) { return TIM_GetCounter(TIM2);\t//返回定时器TIM2的CNT } /* 定时器中断函数，可以复制到使用它的地方 void TIM2_IRQHandler(void) { if (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET) { TIM_ClearITPendingBit(TIM2, TIM_IT_Update); } } */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 //main.c #include \u0026#34;stm32f10x.h\u0026#34; // Device header #include \u0026#34;Delay.h\u0026#34; #include \u0026#34;OLED.h\u0026#34; #include \u0026#34;Timer.h\u0026#34; uint16_t Num;\t//定义在定时器中断里自增的变量 int main(void) { /*模块初始化*/ OLED_Init();\t//OLED初始化 Timer_Init();\t//定时中断初始化 /*显示静态字符串*/ OLED_ShowString(1, 1, \u0026#34;Num:\u0026#34;);\t//1行1列显示字符串Num: OLED_ShowString(2, 1, \u0026#34;CNT:\u0026#34;);\t//2行1列显示字符串CNT: while (1) { OLED_ShowNum(1, 5, Num, 5);\t//不断刷新显示Num变量 OLED_ShowNum(2, 5, Timer_GetCounter(), 5);\t//不断刷新显示CNT的值 } } /** * 函 数：TIM2中断函数 * 参 数：无 * 返 回 值：无 * 注意事项：此函数为中断函数，无需调用，中断触发后自动执行 * 函数名为预留的指定名称，可以从启动文件复制 * 请确保函数名正确，不能有任何差异，否则中断函数将不能进入 */ void TIM2_IRQHandler(void) { if (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET)\t//判断是否是TIM2的更新事件触发的中断 { Num ++;\t//Num变量自增，用于测试定时中断 TIM_ClearITPendingBit(TIM2, TIM_IT_Update);\t//清除TIM2更新事件的中断标志位 //中断标志位必须清除 //否则中断将连续不断地触发，导致主程序卡死 } } 输出比较 输出比较（Output Compare）又称 OC，标准库函数里 TIM.c 中函数名带 OC 的函数均与输出比较有关。\n输出比较是通过比较 CNT 与 CCR 寄存值的关系，来对输出电平置 1、置 0 或电平反转的操作，用于输出一定频率和占空比的 PWM 波形（脉宽调制波形）。\n输出比较通道内部结构解析 每个高级定时器和通用定时器都拥有 4 个输出比较通道，高级定时器的前 3 个通道额外拥有死区生成和互补输出功能。通用定时器输出比较通道内部结构如下图所示：\n计数器当前与 CCR 寄存器内值比较后，输出模式控制器输出一个信号 OC1ref（0、1电平）。该信号来到上图方框 2 处，该处为极性选择电路，若极性选择电路设置为 0则 OC1ref 信号保持不变输出至输出使能电路，当输出使能电路设置为使能时该信号将会通过输出比较通道输出至外界；若极性选择电路设置为 1 则 OC1ref 信号翻转后输出至输出使能电路，当输出使能电路设置为使能时该信号将会通过输出比较通道输出至外 界；\n输出比较模式 输出比较一共有以下 8 中模式，如下图所示： 在 PWM1 模式 1 向上计数模式中（极性不反转的情况下），当 CNT\u0026lt;CCR 时，输出比较通道对应输出有效电平，即高电平（1）。当 CNT\u0026gt;=CCR 时，输出比较通道输出无效电平，即低电平（0）。如下图所示：\nPWM PWM（Pulse Width Modulation）即脉冲宽度调制，在具有惯性的系统中，可以通过对一系列脉冲的宽度进行调制，来等效地获得所需要的模拟参量，常应用于电机控速、开关电源等领域。\nPWM 中有三个重要参数：频率、占空比（高电平时长占整个周期信号时长的比例）、分辨率（占空比可调精度）。实际案例中这三个参数的计算公式如下所示：\n编程实现 基本步骤 相关函数 编程实例 PWM驱动呼吸灯 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 //PWM.c #include \u0026#34;stm32f10x.h\u0026#34; // Device header /** * 函 数：PWM初始化 * 参 数：无 * 返 回 值：无 */ void PWM_Init(void) { /*开启时钟*/ RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);\t//开启TIM2的时钟 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);\t//开启GPIOA的时钟 /*GPIO重映射*/ //\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);\t//开启AFIO的时钟，重映射必须先开启AFIO的时钟 //\tGPIO_PinRemapConfig(GPIO_PartialRemap1_TIM2, ENABLE);\t//将TIM2的引脚部分重映射，具体的映射方案需查看参考手册 //\tGPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable, ENABLE);\t//将JTAG引脚失能，作为普通GPIO引脚使用 /*GPIO初始化*/ GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;\t//GPIO_Pin_15; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, \u0026amp;GPIO_InitStructure);\t//将PA0引脚初始化为复用推挽输出\t//受外设控制的引脚，均需要配置为复用模式\t/*配置时钟源*/ TIM_InternalClockConfig(TIM2);\t//选择TIM2为内部时钟，若不调用此函数，TIM默认也为内部时钟 /*时基单元初始化*/ TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;\t//定义结构体变量 TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1; //时钟分频，选择不分频，此参数用于配置滤波器时钟，不影响时基单元功能 TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; //计数器模式，选择向上计数 TIM_TimeBaseInitStructure.TIM_Period = 100 - 1;\t//计数周期，即ARR的值 TIM_TimeBaseInitStructure.TIM_Prescaler = 720 - 1;\t//预分频器，即PSC的值 TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0; //重复计数器，高级定时器才会用到 TIM_TimeBaseInit(TIM2, \u0026amp;TIM_TimeBaseInitStructure); //将结构体变量交给TIM_TimeBaseInit，配置TIM2的时基单元 /*输出比较初始化*/ TIM_OCInitTypeDef TIM_OCInitStructure;\t//定义结构体变量 TIM_OCStructInit(\u0026amp;TIM_OCInitStructure);\t//结构体初始化，若结构体没有完整赋值 //则最好执行此函数，给结构体所有成员都赋一个默认值 //避免结构体初值不确定的问题 TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;\t//输出比较模式，选择PWM模式1 TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;\t//输出极性，选择为高，若选择极性为低，则输出高低电平取反 TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;\t//输出使能 TIM_OCInitStructure.TIM_Pulse = 0;\t//初始的CCR值 TIM_OC1Init(TIM2, \u0026amp;TIM_OCInitStructure);\t//将结构体变量交给TIM_OC1Init，配置TIM2的输出比较通道1 /*TIM使能*/ TIM_Cmd(TIM2, ENABLE);\t//使能TIM2，定时器开始运行 } /** * 函 数：PWM设置CCR * 参 数：Compare 要写入的CCR的值，范围：0~100 * 返 回 值：无 * 注意事项：CCR和ARR共同决定占空比，此函数仅设置CCR的值，并不直接是占空比 * 占空比Duty = CCR / (ARR + 1) */ void PWM_SetCompare1(uint16_t Compare) { TIM_SetCompare1(TIM2, Compare);\t//设置CCR1的值 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 //LED.c #include \u0026#34;stm32f10x.h\u0026#34; // Device header /** * 函 数：LED初始化 * 参 数：无 * 返 回 值：无 */ void LED_Init(void) { /*开启时钟*/ RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);\t//开启GPIOA的时钟 /*GPIO初始化*/ GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_2; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, \u0026amp;GPIO_InitStructure);\t//将PA1和PA2引脚初始化为推挽输出 /*设置GPIO初始化后的默认电平*/ GPIO_SetBits(GPIOA, GPIO_Pin_1 | GPIO_Pin_2);\t//设置PA1和PA2引脚为高电平 } /** * 函 数：LED1开启 * 参 数：无 * 返 回 值：无 */ void LED1_ON(void) { GPIO_ResetBits(GPIOA, GPIO_Pin_1);\t//设置PA1引脚为低电平 } /** * 函 数：LED1关闭 * 参 数：无 * 返 回 值：无 */ void LED1_OFF(void) { GPIO_SetBits(GPIOA, GPIO_Pin_1);\t//设置PA1引脚为高电平 } /** * 函 数：LED1状态翻转 * 参 数：无 * 返 回 值：无 */ void LED1_Turn(void) { if (GPIO_ReadOutputDataBit(GPIOA, GPIO_Pin_1) == 0)\t//获取输出寄存器的状态，如果当前引脚输出低电平 { GPIO_SetBits(GPIOA, GPIO_Pin_1);\t//则设置PA1引脚为高电平 } else\t//否则，即当前引脚输出高电平 { GPIO_ResetBits(GPIOA, GPIO_Pin_1);\t//则设置PA1引脚为低电平 } } /** * 函 数：LED2开启 * 参 数：无 * 返 回 值：无 */ void LED2_ON(void) { GPIO_ResetBits(GPIOA, GPIO_Pin_2);\t//设置PA2引脚为低电平 } /** * 函 数：LED2关闭 * 参 数：无 * 返 回 值：无 */ void LED2_OFF(void) { GPIO_SetBits(GPIOA, GPIO_Pin_2);\t//设置PA2引脚为高电平 } /** * 函 数：LED2状态翻转 * 参 数：无 * 返 回 值：无 */ void LED2_Turn(void) { if (GPIO_ReadOutputDataBit(GPIOA, GPIO_Pin_2) == 0)\t//获取输出寄存器的状态，如果当前引脚输出低电平 { GPIO_SetBits(GPIOA, GPIO_Pin_2); //则设置PA2引脚为高电平 } else //否则，即当前引脚输出高电平 { GPIO_ResetBits(GPIOA, GPIO_Pin_2); //则设置PA2引脚为低电平 } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 //main.c #include \u0026#34;stm32f10x.h\u0026#34; // Device header #include \u0026#34;Delay.h\u0026#34; #include \u0026#34;OLED.h\u0026#34; #include \u0026#34;PWM.h\u0026#34; uint8_t i;\t//定义for循环的变量 int main(void) { /*模块初始化*/ OLED_Init();\t//OLED初始化 PWM_Init();\t//PWM初始化 while (1) { for (i = 0; i \u0026lt;= 100; i++) { PWM_SetCompare1(i);\t//依次将定时器的CCR寄存器设置为0~100，PWM占空比逐渐增大，LED逐渐变亮 Delay_ms(10);\t//延时10ms } for (i = 0; i \u0026lt;= 100; i++) { PWM_SetCompare1(100 - i);\t//依次将定时器的CCR寄存器设置为100~0，PWM占空比逐渐减小，LED逐渐变暗 Delay_ms(10);\t//延时10ms } } } PWM驱动直流电机 直流电机及驱动简介 直流电机是一种将电能转换为机械能的装置，有两个电极，当电极正接时，电机正转，当电极反接时，电机反转\n直流电机属于大功率器件，GPIO口无法直接驱动，需要配合电机驱动电路来操作\nTB6612是一款双路H桥型的直流电机驱动芯片，可以驱动两个直流电机并且控制其转速和方向\n硬件电路：\n代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 //Motor.c #include \u0026#34;stm32f10x.h\u0026#34; // Device header #include \u0026#34;PWM.h\u0026#34; /** * 函 数：直流电机初始化 * 参 数：无 * 返 回 值：无 */ void Motor_Init(void) { /*开启时钟*/ RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);\t//开启GPIOA的时钟 GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_5; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, \u0026amp;GPIO_InitStructure);\t//将PA4和PA5引脚初始化为推挽输出\tPWM_Init();\t//初始化直流电机的底层PWM } /** * 函 数：直流电机设置速度 * 参 数：Speed 要设置的速度，范围：-100~100 * 返 回 值：无 */ void Motor_SetSpeed(int8_t Speed) { if (Speed \u0026gt;= 0)\t//如果设置正转的速度值 { GPIO_SetBits(GPIOA, GPIO_Pin_4);\t//PA4置高电平 GPIO_ResetBits(GPIOA, GPIO_Pin_5);\t//PA5置低电平，设置方向为正转 PWM_SetCompare3(Speed);\t//PWM设置为速度值 } else\t//否则，即设置反转的速度值 { GPIO_ResetBits(GPIOA, GPIO_Pin_4);\t//PA4置低电平 GPIO_SetBits(GPIOA, GPIO_Pin_5);\t//PA5置高电平，设置方向为反转 PWM_SetCompare3(-Speed);\t//PWM设置为负的速度值，因为此时速度值为负数，而PWM只能给正数 } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 //PWM.c #include \u0026#34;stm32f10x.h\u0026#34; // Device header /** * 函 数：PWM初始化 * 参 数：无 * 返 回 值：无 */ void PWM_Init(void) { /*开启时钟*/ RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);\t//开启TIM2的时钟 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);\t//开启GPIOA的时钟 /*GPIO初始化*/ GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, \u0026amp;GPIO_InitStructure);\t//将PA2引脚初始化为复用推挽输出\t//受外设控制的引脚，均需要配置为复用模式 /*配置时钟源*/ TIM_InternalClockConfig(TIM2);\t//选择TIM2为内部时钟，若不调用此函数，TIM默认也为内部时钟 /*时基单元初始化*/ TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;\t//定义结构体变量 TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1; //时钟分频，选择不分频，此参数用于配置滤波器时钟，不影响时基单元功能 TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; //计数器模式，选择向上计数 TIM_TimeBaseInitStructure.TIM_Period = 100 - 1; //计数周期，即ARR的值 TIM_TimeBaseInitStructure.TIM_Prescaler = 36 - 1; //预分频器，即PSC的值 TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0; //重复计数器，高级定时器才会用到 TIM_TimeBaseInit(TIM2, \u0026amp;TIM_TimeBaseInitStructure); //将结构体变量交给TIM_TimeBaseInit，配置TIM2的时基单元 /*输出比较初始化*/ TIM_OCInitTypeDef TIM_OCInitStructure;\t//定义结构体变量 TIM_OCStructInit(\u0026amp;TIM_OCInitStructure); //结构体初始化，若结构体没有完整赋值 //则最好执行此函数，给结构体所有成员都赋一个默认值 //避免结构体初值不确定的问题 TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1; //输出比较模式，选择PWM模式1 TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High; //输出极性，选择为高，若选择极性为低，则输出高低电平取反 TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; //输出使能 TIM_OCInitStructure.TIM_Pulse = 0;\t//初始的CCR值 TIM_OC3Init(TIM2, \u0026amp;TIM_OCInitStructure); //将结构体变量交给TIM_OC3Init，配置TIM2的输出比较通道3 /*TIM使能*/ TIM_Cmd(TIM2, ENABLE);\t//使能TIM2，定时器开始运行 } /** * 函 数：PWM设置CCR * 参 数：Compare 要写入的CCR的值，范围：0~100 * 返 回 值：无 * 注意事项：CCR和ARR共同决定占空比，此函数仅设置CCR的值，并不直接是占空比 * 占空比Duty = CCR / (ARR + 1) */ void PWM_SetCompare3(uint16_t Compare) { TIM_SetCompare3(TIM2, Compare);\t//设置CCR3的值 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 //main.c #include \u0026#34;stm32f10x.h\u0026#34; // Device header #include \u0026#34;Delay.h\u0026#34; #include \u0026#34;OLED.h\u0026#34; #include \u0026#34;Motor.h\u0026#34; #include \u0026#34;Key.h\u0026#34; uint8_t KeyNum;\t//定义用于接收按键键码的变量 int8_t Speed;\t//定义速度变量 int main(void) { /*模块初始化*/ OLED_Init();\t//OLED初始化 Motor_Init();\t//直流电机初始化 Key_Init();\t//按键初始化 /*显示静态字符串*/ OLED_ShowString(1, 1, \u0026#34;Speed:\u0026#34;);\t//1行1列显示字符串Speed: while (1) { KeyNum = Key_GetNum();\t//获取按键键码 if (KeyNum == 1)\t//按键1按下 { Speed += 20;\t//速度变量自增20 if (Speed \u0026gt; 100)\t//速度变量超过100后 { Speed = -100;\t//速度变量变为-100 //此操作会让电机旋转方向突然改变，可能会因供电不足而导致单片机复位 //若出现了此现象，则应避免使用这样的操作 } } Motor_SetSpeed(Speed);\t//设置直流电机的速度为速度变量 OLED_ShowSignedNum(1, 7, Speed, 3);\t//OLED显示速度变量 } } 输入捕获 输入捕获 输入捕获（Input Capture）又称 IC\n在输入捕获模式下，当通道输入引脚出现指定电平跳变时，当前 CNT 的值将被锁存到CCR 中，可用于测量 PWM 波形的频率、占空比、脉冲间隔、电平持续时间等参数。每个高级定时器和通用定时器都拥有 4 个输入捕获通道，有两种用途：\n1 配置为 PWMI 模式，同时测量频率和占空比\n2 配合主从触发模式，实现硬件全自动测量\n测频原理 以上两种测量方法总结：\n1 测频法适合测试高频信号。在闸门时间内，样本越多（上升沿数量），计次数量就越多则助于减小误差\n2 测周法适合测试低频信号。低频信号周期长，计次数多，误差越小\n3 测频法更新速度相较测周法慢，但数值相对稳定。测周法更新速度快，但数值跳变也快\n4 测频法测试的是闸门时间内的多个周期，自带均值滤波。若在这个闸门时间内捕获到的波形频率不是固定的而是变化的，则会去闸门时间内波形频率的平均值\n5 以上两种测试结果都会存在一个固有误差，即“计次存在正负 1 误差” ：在测频法中，闸门时间 T 结束时刻正好位于上一个信号的下降沿与下一个信号的上升沿之间，因此不是一个完整的周期信号（0.5 个周期信号）。因此可能会将这 0.5 个周期信号看做是一个完整周期信号或者是舍弃这 0.5 个周期信号。因此实际计次会是 N+1(0.5 个周期信号看做完整周期信号)或者是 N-1（舍弃那 0.5 个周期信号）。如下图所示：\n在测周法中，标准的 fc 频率计次，在最后时刻没能完成一次计数时一个周期信号就结束了。因此同样存在正负 1 误差问题。如下图所示：\n因此若想减小正负 1 误差对测试信号频率的影响，应加大计次 N 的数量，当 N 的数量足够大时，正度 1 误差对其的影响就很小\n输入捕获通道：\n此处以 CH1 通道举例解释说明。外部测量信号通过 CH1 通道输入（CH1、CH2、CH3 通道均搭载一个异或门，此门是与三相无刷电机搭配使用的，此处可忽略），信号 TI1 不经过异或门直接进入输入滤波器和边沿检测器（输入滤波器过滤输入信号的毛刺信号），当边沿检测器检测到有触发信号时可触发后续电路。此时可选择给后续电路输出一个或两个触发信号（TI1FP1、TI1FP2 两信号任选其一或均产生）\n1 产生一个 TI1FP1 信号：TI1FP1 信号至 IC1 后置预分频器后，CCR1 寄存器会将当前CNT 计数器的值转运至 CCR1 寄存器中（ CNT 是由内部时钟控制技术的，因此也可以用于计算两个信号之间的时间间隔，此时时间间隔即周期，周期取倒数即频率），同时会产生一个捕获事件或捕获中断。捕获事件会在状态寄存器将状态寄存器标志位置 1（如上图绿色线轨迹）\n2 产生一个 TI1FP2 信号：TI1FP2 信号至 IC2 后置预分频器后，CCR2 寄存器会将当前CNT 计数器的值转运至 CCR2 寄存器中（ CNT 是由内部时钟控制技术的，因此也可以用于计算两个信号之间的时间间隔，此时时间间隔即周期，周期取倒数即频率），同时会产生一个捕获事件或捕获中断。捕获事件会在状态寄存器将状态寄存器标志位置 1（如上图蓝色线轨迹）\n此处设置设置 TI1FP1、TI1FP2 两个通道的好处在于：\n1 CH1、CH2 两通道可以交叉使用，CH3、CH4 两通道可以交叉使用\n2 CH1 可以同时开 TI1FP1、TI1FP2 两个通道，同时测量信号频率，信号占空比\n主从触发模式：\n输入捕获基本结构：\n每一个捕获/比较通道都是围绕着一个捕获/比较寄存器(包含影子寄存器)，包括捕获的输入部分 (数字滤波、多路复用和预分频器)，和输出部分(比较器和输出控制)。 如下图所示： 输入部分对相应的 TIx 输入信号采样，并产生一个滤波后的信号 TIxF。然后，一个带极性选择的 边缘监测器产生一个信号(TIxFPx)，它可以作为从模式控制器的输入触发或者作为捕获控制。该 信号通过预分频进入捕获寄存器(ICxPS)\nPWMI基本结构:\n输入捕获 OC 程序解析 基本步骤 1 开启 TIM3 定时器 RCC 时钟\n2 配置输入捕获引脚\n3 配置 TIM3 定时器时基单元，此处设置时钟源为内部时钟 72M，计数单元频率为72M / 72 = 1M ，即周期为 1us。目标计数值为 65535。 4 配置输入捕获通道（包括通道号、滤波参数、触发方式、分频因子、输入源等）\n5 配置从模式，将 TI1FP1 信号设置为复位时基单元的触发信号\n6 使能定时器 3\n常用函数 编程实例 输入捕获模式测频率 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 //PWM.c #include \u0026#34;stm32f10x.h\u0026#34; // Device header /** * 函 数：PWM初始化 * 参 数：无 * 返 回 值：无 */ void PWM_Init(void) { /*开启时钟*/ RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);\t//开启TIM2的时钟 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);\t//开启GPIOA的时钟 /*GPIO重映射*/ //\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);\t//开启AFIO的时钟，重映射必须先开启AFIO的时钟 //\tGPIO_PinRemapConfig(GPIO_PartialRemap1_TIM2, ENABLE);\t//将TIM2的引脚部分重映射，具体的映射方案需查看参考手册 //\tGPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable, ENABLE);\t//将JTAG引脚失能，作为普通GPIO引脚使用 /*GPIO初始化*/ GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;\t//GPIO_Pin_15; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, \u0026amp;GPIO_InitStructure);\t//将PA0引脚初始化为复用推挽输出\t//受外设控制的引脚，均需要配置为复用模式\t/*配置时钟源*/ TIM_InternalClockConfig(TIM2);\t//选择TIM2为内部时钟，若不调用此函数，TIM默认也为内部时钟 /*时基单元初始化*/ TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;\t//定义结构体变量 TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1; //时钟分频，选择不分频，此参数用于配置滤波器时钟，不影响时基单元功能 TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; //计数器模式，选择向上计数 TIM_TimeBaseInitStructure.TIM_Period = 100 - 1;\t//计数周期，即ARR的值 TIM_TimeBaseInitStructure.TIM_Prescaler = 720 - 1;\t//预分频器，即PSC的值 TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0; //重复计数器，高级定时器才会用到 TIM_TimeBaseInit(TIM2, \u0026amp;TIM_TimeBaseInitStructure); //将结构体变量交给TIM_TimeBaseInit，配置TIM2的时基单元 /*输出比较初始化*/ TIM_OCInitTypeDef TIM_OCInitStructure;\t//定义结构体变量 TIM_OCStructInit(\u0026amp;TIM_OCInitStructure);\t//结构体初始化，若结构体没有完整赋值 //则最好执行此函数，给结构体所有成员都赋一个默认值 //避免结构体初值不确定的问题 TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;\t//输出比较模式，选择PWM模式1 TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;\t//输出极性，选择为高，若选择极性为低，则输出高低电平取反 TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;\t//输出使能 TIM_OCInitStructure.TIM_Pulse = 0;\t//初始的CCR值 TIM_OC1Init(TIM2, \u0026amp;TIM_OCInitStructure);\t//将结构体变量交给TIM_OC1Init，配置TIM2的输出比较通道1 /*TIM使能*/ TIM_Cmd(TIM2, ENABLE);\t//使能TIM2，定时器开始运行 } /** * 函 数：PWM设置CCR * 参 数：Compare 要写入的CCR的值，范围：0~100 * 返 回 值：无 * 注意事项：CCR和ARR共同决定占空比，此函数仅设置CCR的值，并不直接是占空比 * 占空比Duty = CCR / (ARR + 1) */ void PWM_SetCompare1(uint16_t Compare) { TIM_SetCompare1(TIM2, Compare);\t//设置CCR1的值 } /** * 函 数：PWM设置PSC * 参 数：Prescaler 要写入的PSC的值，范围：0~65535 * 返 回 值：无 * 注意事项：PSC和ARR共同决定频率，此函数仅设置PSC的值，并不直接是频率 * 频率Freq = CK_PSC / (PSC + 1) / (ARR + 1) */ void PWM_SetPrescaler(uint16_t Prescaler) { TIM_PrescalerConfig(TIM2, Prescaler, TIM_PSCReloadMode_Immediate);\t//设置PSC的值 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 //IC.c #include \u0026#34;stm32f10x.h\u0026#34; // Device header /** * 函 数：输入捕获初始化 * 参 数：无 * 返 回 值：无 */ void IC_Init(void) { /*开启时钟*/ RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);\t//开启TIM3的时钟 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);\t//开启GPIOA的时钟 /*GPIO初始化*/ GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, \u0026amp;GPIO_InitStructure);\t//将PA6引脚初始化为上拉输入 /*配置时钟源*/ TIM_InternalClockConfig(TIM3);\t//选择TIM3为内部时钟，若不调用此函数，TIM默认也为内部时钟 /*时基单元初始化*/ TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;\t//定义结构体变量 TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1; //时钟分频，选择不分频，此参数用于配置滤波器时钟，不影响时基单元功能 TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; //计数器模式，选择向上计数 TIM_TimeBaseInitStructure.TIM_Period = 65536 - 1; //计数周期，即ARR的值 TIM_TimeBaseInitStructure.TIM_Prescaler = 72 - 1; //预分频器，即PSC的值 TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0; //重复计数器，高级定时器才会用到 TIM_TimeBaseInit(TIM3, \u0026amp;TIM_TimeBaseInitStructure); //将结构体变量交给TIM_TimeBaseInit，配置TIM3的时基单元 /*输入捕获初始化*/ TIM_ICInitTypeDef TIM_ICInitStructure;\t//定义结构体变量 TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;\t//选择配置定时器通道1 TIM_ICInitStructure.TIM_ICFilter = 0xF;\t//输入滤波器参数，可以过滤信号抖动 TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;\t//极性，选择为上升沿触发捕获 TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;\t//捕获预分频，选择不分频，每次信号都触发捕获 TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;\t//输入信号交叉，选择直通，不交叉 TIM_ICInit(TIM3, \u0026amp;TIM_ICInitStructure);\t//将结构体变量交给TIM_ICInit，配置TIM3的输入捕获通道 /*选择触发源及从模式*/ TIM_SelectInputTrigger(TIM3, TIM_TS_TI1FP1);\t//触发源选择TI1FP1 TIM_SelectSlaveMode(TIM3, TIM_SlaveMode_Reset);\t//从模式选择复位 //即TI1产生上升沿时，会触发CNT归零 /*TIM使能*/ TIM_Cmd(TIM3, ENABLE);\t//使能TIM3，定时器开始运行 } /** * 函 数：获取输入捕获的频率 * 参 数：无 * 返 回 值：捕获得到的频率 */ uint32_t IC_GetFreq(void) { return 1000000 / (TIM_GetCapture1(TIM3) + 1);\t//测周法得到频率fx = fc / N，这里不执行+1的操作也可 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 //main.c #include \u0026#34;stm32f10x.h\u0026#34; // Device header #include \u0026#34;Delay.h\u0026#34; #include \u0026#34;OLED.h\u0026#34; #include \u0026#34;PWM.h\u0026#34; #include \u0026#34;IC.h\u0026#34; int main(void) { /*模块初始化*/ OLED_Init();\t//OLED初始化 PWM_Init();\t//PWM初始化 IC_Init();\t//输入捕获初始化 /*显示静态字符串*/ OLED_ShowString(1, 1, \u0026#34;Freq:00000Hz\u0026#34;);\t//1行1列显示字符串Freq:00000Hz /*使用PWM模块提供输入捕获的测试信号*/ PWM_SetPrescaler(720 - 1);\t//PWM频率Freq = 72M / (PSC + 1) / 100 PWM_SetCompare1(50);\t//PWM占空比Duty = CCR / 100 while (1) { OLED_ShowNum(1, 6, IC_GetFreq(), 5);\t//不断刷新显示输入捕获测得的频率 } } PWMI 模式测频率占空比 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 //PWM.c #include \u0026#34;stm32f10x.h\u0026#34; // Device header /** * 函 数：PWM初始化 * 参 数：无 * 返 回 值：无 */ void PWM_Init(void) { /*开启时钟*/ RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);\t//开启TIM2的时钟 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);\t//开启GPIOA的时钟 /*GPIO重映射*/ //\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);\t//开启AFIO的时钟，重映射必须先开启AFIO的时钟 //\tGPIO_PinRemapConfig(GPIO_PartialRemap1_TIM2, ENABLE);\t//将TIM2的引脚部分重映射，具体的映射方案需查看参考手册 //\tGPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable, ENABLE);\t//将JTAG引脚失能，作为普通GPIO引脚使用 /*GPIO初始化*/ GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;\t//GPIO_Pin_15; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, \u0026amp;GPIO_InitStructure);\t//将PA0引脚初始化为复用推挽输出\t//受外设控制的引脚，均需要配置为复用模式\t/*配置时钟源*/ TIM_InternalClockConfig(TIM2);\t//选择TIM2为内部时钟，若不调用此函数，TIM默认也为内部时钟 /*时基单元初始化*/ TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;\t//定义结构体变量 TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1; //时钟分频，选择不分频，此参数用于配置滤波器时钟，不影响时基单元功能 TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; //计数器模式，选择向上计数 TIM_TimeBaseInitStructure.TIM_Period = 100 - 1;\t//计数周期，即ARR的值 TIM_TimeBaseInitStructure.TIM_Prescaler = 720 - 1;\t//预分频器，即PSC的值 TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0; //重复计数器，高级定时器才会用到 TIM_TimeBaseInit(TIM2, \u0026amp;TIM_TimeBaseInitStructure); //将结构体变量交给TIM_TimeBaseInit，配置TIM2的时基单元 /*输出比较初始化*/ TIM_OCInitTypeDef TIM_OCInitStructure;\t//定义结构体变量 TIM_OCStructInit(\u0026amp;TIM_OCInitStructure);\t//结构体初始化，若结构体没有完整赋值 //则最好执行此函数，给结构体所有成员都赋一个默认值 //避免结构体初值不确定的问题 TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;\t//输出比较模式，选择PWM模式1 TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;\t//输出极性，选择为高，若选择极性为低，则输出高低电平取反 TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;\t//输出使能 TIM_OCInitStructure.TIM_Pulse = 0;\t//初始的CCR值 TIM_OC1Init(TIM2, \u0026amp;TIM_OCInitStructure);\t//将结构体变量交给TIM_OC1Init，配置TIM2的输出比较通道1 /*TIM使能*/ TIM_Cmd(TIM2, ENABLE);\t//使能TIM2，定时器开始运行 } /** * 函 数：PWM设置CCR * 参 数：Compare 要写入的CCR的值，范围：0~100 * 返 回 值：无 * 注意事项：CCR和ARR共同决定占空比，此函数仅设置CCR的值，并不直接是占空比 * 占空比Duty = CCR / (ARR + 1) */ void PWM_SetCompare1(uint16_t Compare) { TIM_SetCompare1(TIM2, Compare);\t//设置CCR1的值 } /** * 函 数：PWM设置PSC * 参 数：Prescaler 要写入的PSC的值，范围：0~65535 * 返 回 值：无 * 注意事项：PSC和ARR共同决定频率，此函数仅设置PSC的值，并不直接是频率 * 频率Freq = CK_PSC / (PSC + 1) / (ARR + 1) */ void PWM_SetPrescaler(uint16_t Prescaler) { TIM_PrescalerConfig(TIM2, Prescaler, TIM_PSCReloadMode_Immediate);\t//设置PSC的值 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 //IC.c #include \u0026#34;stm32f10x.h\u0026#34; // Device header /** * 函 数：输入捕获初始化 * 参 数：无 * 返 回 值：无 */ void IC_Init(void) { /*开启时钟*/ RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);\t//开启TIM3的时钟 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);\t//开启GPIOA的时钟 /*GPIO初始化*/ GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, \u0026amp;GPIO_InitStructure);\t//将PA6引脚初始化为上拉输入 /*配置时钟源*/ TIM_InternalClockConfig(TIM3);\t//选择TIM3为内部时钟，若不调用此函数，TIM默认也为内部时钟 /*时基单元初始化*/ TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;\t//定义结构体变量 TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1; //时钟分频，选择不分频，此参数用于配置滤波器时钟，不影响时基单元功能 TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; //计数器模式，选择向上计数 TIM_TimeBaseInitStructure.TIM_Period = 65536 - 1; //计数周期，即ARR的值 TIM_TimeBaseInitStructure.TIM_Prescaler = 72 - 1; //预分频器，即PSC的值 TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0; //重复计数器，高级定时器才会用到 TIM_TimeBaseInit(TIM3, \u0026amp;TIM_TimeBaseInitStructure); //将结构体变量交给TIM_TimeBaseInit，配置TIM3的时基单元 /*PWMI模式初始化*/ TIM_ICInitTypeDef TIM_ICInitStructure;\t//定义结构体变量 TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;\t//选择配置定时器通道1 TIM_ICInitStructure.TIM_ICFilter = 0xF;\t//输入滤波器参数，可以过滤信号抖动 TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;\t//极性，选择为上升沿触发捕获 TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;\t//捕获预分频，选择不分频，每次信号都触发捕获 TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;\t//输入信号交叉，选择直通，不交叉 TIM_PWMIConfig(TIM3, \u0026amp;TIM_ICInitStructure);\t//将结构体变量交给TIM_PWMIConfig，配置TIM3的输入捕获通道 //此函数同时会把另一个通道配置为相反的配置，实现PWMI模式 /*选择触发源及从模式*/ TIM_SelectInputTrigger(TIM3, TIM_TS_TI1FP1);\t//触发源选择TI1FP1 TIM_SelectSlaveMode(TIM3, TIM_SlaveMode_Reset);\t//从模式选择复位 //即TI1产生上升沿时，会触发CNT归零 /*TIM使能*/ TIM_Cmd(TIM3, ENABLE);\t//使能TIM3，定时器开始运行 } /** * 函 数：获取输入捕获的频率 * 参 数：无 * 返 回 值：捕获得到的频率 */ uint32_t IC_GetFreq(void) { return 1000000 / (TIM_GetCapture1(TIM3) + 1);\t//测周法得到频率fx = fc / N，这里不执行+1的操作也可 } /** * 函 数：获取输入捕获的占空比 * 参 数：无 * 返 回 值：捕获得到的占空比 */ uint32_t IC_GetDuty(void) { return (TIM_GetCapture2(TIM3) + 1) * 100 / (TIM_GetCapture1(TIM3) + 1);\t//占空比Duty = CCR2 / CCR1 * 100，这里不执行+1的操作也可 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 //main.c #include \u0026#34;stm32f10x.h\u0026#34; // Device header #include \u0026#34;Delay.h\u0026#34; #include \u0026#34;OLED.h\u0026#34; #include \u0026#34;PWM.h\u0026#34; #include \u0026#34;IC.h\u0026#34; int main(void) { /*模块初始化*/ OLED_Init();\t//OLED初始化 PWM_Init();\t//PWM初始化 IC_Init();\t//输入捕获初始化 /*显示静态字符串*/ OLED_ShowString(1, 1, \u0026#34;Freq:00000Hz\u0026#34;);\t//1行1列显示字符串Freq:00000Hz OLED_ShowString(2, 1, \u0026#34;Duty:00%\u0026#34;);\t//2行1列显示字符串Duty:00% /*使用PWM模块提供输入捕获的测试信号*/ PWM_SetPrescaler(720 - 1);\t//PWM频率Freq = 72M / (PSC + 1) / 100 PWM_SetCompare1(50);\t//PWM占空比Duty = CCR / 100 while (1) { OLED_ShowNum(1, 6, IC_GetFreq(), 5);\t//不断刷新显示输入捕获测得的频率 OLED_ShowNum(2, 6, IC_GetDuty(), 2);\t//不断刷新显示输入捕获测得的占空比 } } ","date":"2025-04-08T18:04:40+08:00","permalink":"https://ZCFZEUS.github.io/p/stm323-%E5%AE%9A%E6%97%B6%E5%99%A8/","title":"Stm32(3) 定时器"},{"content":"中断概述 中断：在主程序运行过程中，出现了特定的中断触发条件（中断源），使得CPU暂停当前正在运行的程序，转而去处理中断程序，处理完成后又返回原来被暂停的位置继续运行\n中断优先级：当有多个中断源同时申请中断时，CPU会根据中断源的轻重缓急进行裁决，优先响应更加紧急的中断源\n中断嵌套：当一个中断程序正在运行时，又有新的更高优先级的中断源申请中断，CPU再次暂停当前中断程序，转而去处理新的中断程序，处理完成后依次进行返回\n执行流程:\nSTM32中断 68个可屏蔽中断通道，包含EXTI、TIM、ADC、USART、SPI、I2C、RTC等多个外设\n使用NVIC统一管理中断，每个中断通道都拥有16个可编程的优先等级，可对优先级进行分组，进一步设置抢占优先级和响应优先级\nNVIC中断优先级分组 NVIC 的主要功能是管理 STM32 中的中断，并给中断分配优先级，每个中断通道都拥有16 个可编程的优先等级，可对优先级进行分组，设置抢占优先级和响应优先级。\n中断管理方法：首先，对 STM32 中断进行分组，组 0~4。同时，对每个中断设置一个抢占优先级和一个响应优先级值。\n分组配置是在寄存器 SCB-\u0026gt;AIRCR 中配置：\n抢占优先级\u0026amp;响应优先级区别（0 为最高优先级，1 位次高优先级。依次规律\u0026hellip;）：\n1 高优先级的抢占优先级是可以打断正在执行的低抢占优先级中断的。\n2 抢占优先级相同的中断，高响应优先级不可以打断低优响应优先级的中断。\n3 抢占优先级相同的中断，当两个中断同时发生的情况，那个优先级高，哪个先执行。\n4 如果两个中断的抢占优先级和响应优先级都一样的话，则看哪个中断先发生就先执行。\n举例说明：假设此时初始化有中断 3、中断 6、中断 7 三个中断。将中断优先组设置为2。中断 3 的抢占优先级为 2，响应优先级为 1。中断 6 的抢占优先级为 3，响应优先级为 0。中断 7 的抢占优先级为 2，响应优先级为 0；则此时这三个中断的优先级顺序为：中断 7\u0026gt;中断 3\u0026gt;中断 6。\n特别说明：系统代码执行过程中，只设置一次中断优先级组别（在主函数内初始化一次），若在程序运行过程中随意改变分组会导致中断管理混乱，程序会出现意想不到的执行结果。\nEXTI解析及其内部结构图 EXTI 解析 EXTI(Extern Interrupt)外部中断\n外部中断可以监测指定 GPIO 口的电平信号，当其指定的 GPIO 口产生电平变化时，外部中断将立即向 NVIC 发出中断申请，经过 NVIC 裁决后即可中断 CPU 主程序，使 CPU 暂停\n正在执行的主程序转而执行 EXTI 对应的中断程序。\nEXTI 支持的触发方式有：上升沿触发、下降沿触发、双边沿触发（即上升沿和下降沿均可触发）、软件触发四种方式。\nEXTI 支持的 GPIO 口：所有的 GPIO 口均支持外部中断，但相同的 Pin 不能同时触发中断。\nEXTI 共 20 个输入通道：16 个 GPIO_Pin、PVD 输出、RTC 闹钟、USB 唤醒、以太网唤醒。\nEXTI 触发响应方式有：中断响应或事件响应（选择触发事件，外部中断的信号将不会通向 CPU，而是通往其他外设，用来触发其他外设。如：触发 ADC 转换、触发 DMA）两种方式。\n外部中断/事件线路映像 在 STM32F103C8T6 单片机中有 GPIO4、GPIOB、GPIOC 三组共 48 个 IO 口，却只有 16 个 GPIO_Pin 外部中断通道。其内部采用映射的方式将所有 GPIO_Pin0 源映射至 EXTI0、GPIO_Pin1 源映射至 EXTI1（以此类推）上，最后通过 EXTI 通道通过选择器选择触发中断的中断源。这种方式使所有 IO 均支持外部中断的，但也使相同的 GPIO_Pin 中断源不能同时触发中断。其内部映射图如下所示：\nEXTI 内部结构图 EXTI 编程思路总结 外部中断初始化设置步骤总结：\n1 配置外部中断引脚的 IO 口以及时钟(GPIO,AFIO,NVIC,EXTI)\n2 配置GPIO\n3 配置AFIO，选择GPIO连接EXTI\n4 配置EXTI，选择边沿触发方式，以及响应方式\n5 配置NVIC，选择合适优先级\n6 在中断函数中实现相关功能\n相关函数 编程实例 对射红外传感器计次 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 //CountSensor.c #include \u0026#34;stm32f10x.h\u0026#34; // Device header uint16_t CountSensor_Count;\t//全局变量，用于计数 /** * 函 数：计数传感器初始化 * 参 数：无 * 返 回 值：无 */ void CountSensor_Init(void) { /*开启时钟*/ RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);\t//开启GPIOB的时钟 RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);\t//开启AFIO的时钟，外部中断必须开启AFIO的时钟 /*GPIO初始化*/ GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOB, \u0026amp;GPIO_InitStructure);\t//将PB14引脚初始化为上拉输入 /*AFIO选择中断引脚*/ GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource14);//将外部中断的14号线映射到GPIOB，即选择PB14为外部中断引脚 /*EXTI初始化*/ EXTI_InitTypeDef EXTI_InitStructure;\t//定义结构体变量 EXTI_InitStructure.EXTI_Line = EXTI_Line14;\t//选择配置外部中断的14号线 EXTI_InitStructure.EXTI_LineCmd = ENABLE;\t//指定外部中断线使能 EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;\t//指定外部中断线为中断模式 EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;\t//指定外部中断线为下降沿触发 EXTI_Init(\u0026amp;EXTI_InitStructure);\t//将结构体变量交给EXTI_Init，配置EXTI外设 /*NVIC中断分组*/ NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);\t//配置NVIC为分组2 //即抢占优先级范围：0~3，响应优先级范围：0~3 //此分组配置在整个工程中仅需调用一次 //若有多个中断，可以把此代码放在main函数内，while循环之前 //若调用多次配置分组的代码，则后执行的配置会覆盖先执行的配置 /*NVIC配置*/ NVIC_InitTypeDef NVIC_InitStructure;\t//定义结构体变量 NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;\t//选择配置NVIC的EXTI15_10线 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;\t//指定NVIC线路使能 NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;\t//指定NVIC线路的抢占优先级为1 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;\t//指定NVIC线路的响应优先级为1 NVIC_Init(\u0026amp;NVIC_InitStructure);\t//将结构体变量交给NVIC_Init，配置NVIC外设 } /** * 函 数：获取计数传感器的计数值 * 参 数：无 * 返 回 值：计数值，范围：0~65535 */ uint16_t CountSensor_Get(void) { return CountSensor_Count; } /** * 函 数：EXTI15_10外部中断函数 * 参 数：无 * 返 回 值：无 * 注意事项：此函数为中断函数，无需调用，中断触发后自动执行 * 函数名为预留的指定名称，可以从启动文件复制 * 请确保函数名正确，不能有任何差异，否则中断函数将不能进入 */ void EXTI15_10_IRQHandler(void) { if (EXTI_GetITStatus(EXTI_Line14) == SET)\t//判断是否是外部中断14号线触发的中断 { /*如果出现数据乱跳的现象，可再次判断引脚电平，以避免抖动*/ if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_14) == 0) { CountSensor_Count ++;\t//计数值自增一次 } EXTI_ClearITPendingBit(EXTI_Line14);\t//清除外部中断14号线的中断标志位 //中断标志位必须清除 //否则中断将连续不断地触发，导致主程序卡死 } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 //main.c #include \u0026#34;stm32f10x.h\u0026#34; // Device header #include \u0026#34;Delay.h\u0026#34; #include \u0026#34;OLED.h\u0026#34; #include \u0026#34;CountSensor.h\u0026#34; int main(void) { /*模块初始化*/ OLED_Init();\t//OLED初始化 CountSensor_Init();\t//计数传感器初始化 /*显示静态字符串*/ OLED_ShowString(1, 1, \u0026#34;Count:\u0026#34;);\t//1行1列显示字符串Count: while (1) { OLED_ShowNum(1, 7, CountSensor_Get(), 5);\t//OLED不断刷新显示CountSensor_Get的返回值 } } 旋转编码器计次 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 //Encoder.c #include \u0026#34;stm32f10x.h\u0026#34; // Device header int16_t Encoder_Count;\t//全局变量，用于计数旋转编码器的增量值 /** * 函 数：旋转编码器初始化 * 参 数：无 * 返 回 值：无 */ void Encoder_Init(void) { /*开启时钟*/ RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);\t//开启GPIOB的时钟 RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);\t//开启AFIO的时钟，外部中断必须开启AFIO的时钟 /*GPIO初始化*/ GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOB, \u0026amp;GPIO_InitStructure);\t//将PB0和PB1引脚初始化为上拉输入 /*AFIO选择中断引脚*/ GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource0);//将外部中断的0号线映射到GPIOB，即选择PB0为外部中断引脚 GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource1);//将外部中断的1号线映射到GPIOB，即选择PB1为外部中断引脚 /*EXTI初始化*/ EXTI_InitTypeDef EXTI_InitStructure;\t//定义结构体变量 EXTI_InitStructure.EXTI_Line = EXTI_Line0 | EXTI_Line1;\t//选择配置外部中断的0号线和1号线 EXTI_InitStructure.EXTI_LineCmd = ENABLE;\t//指定外部中断线使能 EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;\t//指定外部中断线为中断模式 EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;\t//指定外部中断线为下降沿触发 EXTI_Init(\u0026amp;EXTI_InitStructure);\t//将结构体变量交给EXTI_Init，配置EXTI外设 /*NVIC中断分组*/ NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);\t//配置NVIC为分组2 //即抢占优先级范围：0~3，响应优先级范围：0~3 //此分组配置在整个工程中仅需调用一次 //若有多个中断，可以把此代码放在main函数内，while循环之前 //若调用多次配置分组的代码，则后执行的配置会覆盖先执行的配置 /*NVIC配置*/ NVIC_InitTypeDef NVIC_InitStructure;\t//定义结构体变量 NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn;\t//选择配置NVIC的EXTI0线 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;\t//指定NVIC线路使能 NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;\t//指定NVIC线路的抢占优先级为1 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;\t//指定NVIC线路的响应优先级为1 NVIC_Init(\u0026amp;NVIC_InitStructure);\t//将结构体变量交给NVIC_Init，配置NVIC外设 NVIC_InitStructure.NVIC_IRQChannel = EXTI1_IRQn;\t//选择配置NVIC的EXTI1线 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;\t//指定NVIC线路使能 NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;\t//指定NVIC线路的抢占优先级为1 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;\t//指定NVIC线路的响应优先级为2 NVIC_Init(\u0026amp;NVIC_InitStructure);\t//将结构体变量交给NVIC_Init，配置NVIC外设 } /** * 函 数：旋转编码器获取增量值 * 参 数：无 * 返 回 值：自上此调用此函数后，旋转编码器的增量值 */ int16_t Encoder_Get(void) { /*使用Temp变量作为中继，目的是返回Encoder_Count后将其清零*/ /*在这里，也可以直接返回Encoder_Count 但这样就不是获取增量值的操作方法了 也可以实现功能，只是思路不一样*/ int16_t Temp; Temp = Encoder_Count; Encoder_Count = 0; return Temp; } /** * 函 数：EXTI0外部中断函数 * 参 数：无 * 返 回 值：无 * 注意事项：此函数为中断函数，无需调用，中断触发后自动执行 * 函数名为预留的指定名称，可以从启动文件复制 * 请确保函数名正确，不能有任何差异，否则中断函数将不能进入 */ void EXTI0_IRQHandler(void) { if (EXTI_GetITStatus(EXTI_Line0) == SET)\t//判断是否是外部中断0号线触发的中断 { /*如果出现数据乱跳的现象，可再次判断引脚电平，以避免抖动*/ if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_0) == 0) { if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1) == 0)\t//PB0的下降沿触发中断，此时检测另一相PB1的电平，目的是判断旋转方向 { Encoder_Count --;\t//此方向定义为反转，计数变量自减 } } EXTI_ClearITPendingBit(EXTI_Line0);\t//清除外部中断0号线的中断标志位 //中断标志位必须清除 //否则中断将连续不断地触发，导致主程序卡死 } } /** * 函 数：EXTI1外部中断函数 * 参 数：无 * 返 回 值：无 * 注意事项：此函数为中断函数，无需调用，中断触发后自动执行 * 函数名为预留的指定名称，可以从启动文件复制 * 请确保函数名正确，不能有任何差异，否则中断函数将不能进入 */ void EXTI1_IRQHandler(void) { if (EXTI_GetITStatus(EXTI_Line1) == SET)\t//判断是否是外部中断1号线触发的中断 { /*如果出现数据乱跳的现象，可再次判断引脚电平，以避免抖动*/ if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1) == 0) { if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_0) == 0)\t//PB1的下降沿触发中断，此时检测另一相PB0的电平，目的是判断旋转方向 { Encoder_Count ++;\t//此方向定义为正转，计数变量自增 } } EXTI_ClearITPendingBit(EXTI_Line1);\t//清除外部中断1号线的中断标志位 //中断标志位必须清除 //否则中断将连续不断地触发，导致主程序卡死 } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 //main.c #include \u0026#34;stm32f10x.h\u0026#34; // Device header #include \u0026#34;Delay.h\u0026#34; #include \u0026#34;OLED.h\u0026#34; #include \u0026#34;Encoder.h\u0026#34; int16_t Num;\t//定义待被旋转编码器调节的变量 int main(void) { /*模块初始化*/ OLED_Init();\t//OLED初始化 Encoder_Init();\t//旋转编码器初始化 /*显示静态字符串*/ OLED_ShowString(1, 1, \u0026#34;Num:\u0026#34;);\t//1行1列显示字符串Num: while (1) { Num += Encoder_Get();\t//获取自上此调用此函数后，旋转编码器的增量值，并将增量值加到Num上 OLED_ShowSignedNum(1, 5, Num, 5);\t//显示Num } } ","date":"2025-04-08T16:46:47+08:00","permalink":"https://ZCFZEUS.github.io/p/stm322-%E4%B8%AD%E6%96%AD/","title":"Stm32(2)-中断"},{"content":"概述 GPIO,即通用 I/O(输入/输出)端口，是 STM32 可控制的引脚。STM32 芯片的 GPIO 引脚与外部设备连接起来，可实现与外部通讯、控制外部硬件或者采集外部硬件数据的功能。STM32F103 有 3 组 IO。分别为 GPIOA~GPIOC，每组 IO 有 16 个 IO 口，共有 48 个 IO 口。通常称为 PAx、PBx、PCx，其中 x 为 0-15，并且 F1 系列是基于 Cortex-M3 内核。\nGPIO 的复用：STM32F1 有很多的内置外设，这些外设的外部引脚都是与 GPIO 共用的。也就是说，一个引脚可以有很多作用，但是默认为 IO 口，如果想使用一个 GPIO 内置外设的功能引脚，就需要 GPIO 的复用，那么当这个 GPIO 作为内置外设使用的时候，就叫做复用。比如说串口就是 GPIO 复用为串口。\nGPIO 可以被配置为 8 中状态，其中输入输出各 4 种状态。\n输出模式：可控制端口输出高低电平，用以驱动LED、控制蜂鸣器、模拟通信协议输出时序等\n1 通用推挽输出\n2 通用开漏输出\n3 复用功能推挽输出模式\n4 复用功能开漏输出模式\n输入模式:读取端口的高低电平或电压，用于读取按键输入、外接模块电平信号输入、ADC电压采集、模拟通信协议接收数据等\n5 模拟输入模式\n6 浮空输入模式\n7 上拉输入模式\n8 下拉输入模式\n详述 结构 基本机构：\n位结构：\nGPIO模式：\n通过配置GPIO的端口配置寄存器，端口可以配置成以下8种模式：\n输出配置 对 I/O 端口进行编程作为输出时：\n1 输出缓冲器被打开：\n\u0026ndash;开漏模式：输出寄存器中的“0”可激活 N-MOS，而输出寄存器中的“1”会使端口保持高组态 (Hi-Z)（P-MOS 始终不激活）。\n\u0026ndash;推挽模式：输出寄存器中的“0”可激活 N-MOS，而输出寄存器中的“1”可激活 P-MOS。\n2 施密特触发器输入被打开\n3 根据 GPIOx_PUPDR 寄存器中的值决定是否打开弱上拉电阻和下拉电阻\n4 输入数据寄存器每隔 1 个 AHB1 时钟周期对 I/O 引脚上的数据进行一次采样\n5 对输入数据寄存器的读访问可获取 I/O 状态\n6 对输出数据寄存器的读访问可获取最后的写入值\n推挽电路（push-pull）就是两个不同极性晶体管间连接的输出电路。推挽电路采用两个参数相同的功率 BJT 管或 MOSFET 管，以推挽方式存在于电路中，各负责正负半周的波形放大任务，电路工作时，两只对称的功率开关管每次只有一个导通，所以导通损耗小效率高。推挽输出既可以向负载灌电流，也可以从负载抽取电流。 在电路设计中，推挽输出是一种很常用的输出模式。推挽输出有很多优点，比如更低的损耗，更安全的输出等。推挽”之意，即为当一个管子推出去时，另一个管子拉回来。输入不同，交替导通。\n当输入信号为高电平的时候，上面的管子导通，下面的管子截止，输出信号为高电平。\n当输入信号为低电平的时候，上面的管子截止，下面的管子导通，输出信号为低电平。\n输入配置 对 I/O 端口进行编程作为输入时：\n1 输出缓冲器被关闭\n2 施密特触发器输入被打开\n3 根据 GPIOx_PUPDR 寄存器中的值决定是否打开上拉和下拉电阻\n4 输入数据寄存器每隔 1 个 AHB1 时钟周期对 I/O 引脚上的数据进行一次采样\n5 对输入数据寄存器的读访问可获取 I/O 状态\n复用功能配置 对 I/O 端口进行编程作为复用功能时：\n1 可将输出缓冲器配置为开漏或推挽\n2 输出缓冲器由来自外设的信号驱动（发送器使能和数据）\n3 施密特触发器输入被打开\n4 根据 GPIOx_PUPDR 寄存器中的值决定是否打开上拉电阻和下拉电阻\n5 输入数据寄存器每隔 1 个 AHB1 时钟周期对 I/O 引脚上的数据进行一次采样\n6 对输入数据寄存器的读访问可获取 I/O 状态\n模拟配置 对 I/O 端口进行编程作为模拟配置时：\n1 输出缓冲器被禁止。\n2 施密特触发器输入停用，I/O 引脚的每个模拟输入的功耗变为零。施密特触发器的输出被强制处理为恒定值 (0)。 3 弱上拉和下拉电阻被关闭。\n4 对输入数据寄存器的读访问值为“0”。\n注：在模拟配置中，I/O 引脚不能为 5 V 容忍\nGPIO 库函数编程 调用 GPIO 寄存器步骤总结：\n①端口硬件时钟使能\n②GPIO 的初始化\n③GPIO 初始化结构体\n④GPIO 的引脚电平设置\n1 设置高电平\n2 设置低电平\n设置引脚电平，也可以尝试 GPIO_Write、GPIO_WriteBit 函数\n3 读取某个端口的引脚电平\n编程实例 LED闪烁 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026#34;stm32f10x.h\u0026#34; // Device header #include \u0026#34;Delay.h\u0026#34; int main(void) { /*开启时钟*/ RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);\t//开启GPIOA的时钟 //使用各个外设前必须开启时钟，否则对外设的操作无效 /*GPIO初始化*/ GPIO_InitTypeDef GPIO_InitStructure;\t//定义结构体变量 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;\t//GPIO模式，赋值为推挽输出模式 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;\t//GPIO引脚，赋值为第0号引脚 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\t//GPIO速度，赋值为50MHz GPIO_Init(GPIOA, \u0026amp;GPIO_InitStructure);\t//将赋值后的构体变量传递给GPIO_Init函数 //函数内部会自动根据结构体的参数配置相应寄存器 //实现GPIOA的初始化 /*主循环，循环体内的代码会一直循环执行*/ while (1) { /*设置PA0引脚的高低电平，实现LED闪烁，下面展示3种方法*/ /*方法1：GPIO_ResetBits设置低电平，GPIO_SetBits设置高电平*/ GPIO_ResetBits(GPIOA, GPIO_Pin_0);\t//将PA0引脚设置为低电平 Delay_ms(500);\t//延时500ms GPIO_SetBits(GPIOA, GPIO_Pin_0);\t//将PA0引脚设置为高电平 Delay_ms(500);\t//延时500ms /*方法2：GPIO_WriteBit设置低/高电平，由Bit_RESET/Bit_SET指定*/ GPIO_WriteBit(GPIOA, GPIO_Pin_0, Bit_RESET);\t//将PA0引脚设置为低电平 Delay_ms(500);\t//延时500ms GPIO_WriteBit(GPIOA, GPIO_Pin_0, Bit_SET);\t//将PA0引脚设置为高电平 Delay_ms(500);\t//延时500ms /*方法3：GPIO_WriteBit设置低/高电平，由数据0/1指定，数据需要强转为BitAction类型*/ GPIO_WriteBit(GPIOA, GPIO_Pin_0, (BitAction)0);\t//将PA0引脚设置为低电平 Delay_ms(500);\t//延时500ms GPIO_WriteBit(GPIOA, GPIO_Pin_0, (BitAction)1);\t//将PA0引脚设置为高电平 Delay_ms(500);\t//延时500ms } } LED流水灯 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026#34;stm32f10x.h\u0026#34; // Device header #include \u0026#34;Delay.h\u0026#34; int main(void) { /*开启时钟*/ RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);\t//开启GPIOA的时钟 //使用各个外设前必须开启时钟，否则对外设的操作无效 /*GPIO初始化*/ GPIO_InitTypeDef GPIO_InitStructure;\t//定义结构体变量 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;\t//GPIO模式，赋值为推挽输出模式 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_All;\t//GPIO引脚，赋值为所有引脚 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\t//GPIO速度，赋值为50MHz GPIO_Init(GPIOA, \u0026amp;GPIO_InitStructure);\t//将赋值后的构体变量传递给GPIO_Init函数 //函数内部会自动根据结构体的参数配置相应寄存器 //实现GPIOA的初始化 /*主循环，循环体内的代码会一直循环执行*/ while (1) { /*使用GPIO_Write，同时设置GPIOA所有引脚的高低电平，实现LED流水灯*/ GPIO_Write(GPIOA, ~0x0001);\t//0000 0000 0000 0001，PA0引脚为低电平，其他引脚均为高电平，注意数据有按位取反 Delay_ms(100);\t//延时100ms GPIO_Write(GPIOA, ~0x0002);\t//0000 0000 0000 0010，PA1引脚为低电平，其他引脚均为高电平 Delay_ms(100);\t//延时100ms GPIO_Write(GPIOA, ~0x0004);\t//0000 0000 0000 0100，PA2引脚为低电平，其他引脚均为高电平 Delay_ms(100);\t//延时100ms GPIO_Write(GPIOA, ~0x0008);\t//0000 0000 0000 1000，PA3引脚为低电平，其他引脚均为高电平 Delay_ms(100);\t//延时100ms GPIO_Write(GPIOA, ~0x0010);\t//0000 0000 0001 0000，PA4引脚为低电平，其他引脚均为高电平 Delay_ms(100);\t//延时100ms GPIO_Write(GPIOA, ~0x0020);\t//0000 0000 0010 0000，PA5引脚为低电平，其他引脚均为高电平 Delay_ms(100);\t//延时100ms GPIO_Write(GPIOA, ~0x0040);\t//0000 0000 0100 0000，PA6引脚为低电平，其他引脚均为高电平 Delay_ms(100);\t//延时100ms GPIO_Write(GPIOA, ~0x0080);\t//0000 0000 1000 0000，PA7引脚为低电平，其他引脚均为高电平 Delay_ms(100);\t//延时100ms } } 蜂鸣器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026#34;stm32f10x.h\u0026#34; // Device header #include \u0026#34;Delay.h\u0026#34; int main(void) { /*开启时钟*/ RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);\t//开启GPIOB的时钟 //使用各个外设前必须开启时钟，否则对外设的操作无效 /*GPIO初始化*/ GPIO_InitTypeDef GPIO_InitStructure;\t//定义结构体变量 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;\t//GPIO模式，赋值为推挽输出模式 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;\t//GPIO引脚，赋值为第12号引脚 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\t//GPIO速度，赋值为50MHz GPIO_Init(GPIOB, \u0026amp;GPIO_InitStructure);\t//将赋值后的构体变量传递给GPIO_Init函数 //函数内部会自动根据结构体的参数配置相应寄存器 //实现GPIOB的初始化 /*主循环，循环体内的代码会一直循环执行*/ while (1) { GPIO_ResetBits(GPIOB, GPIO_Pin_12);\t//将PB12引脚设置为低电平，蜂鸣器鸣叫 Delay_ms(100);\t//延时100ms GPIO_SetBits(GPIOB, GPIO_Pin_12);\t//将PB12引脚设置为高电平，蜂鸣器停止 Delay_ms(100);\t//延时100ms GPIO_ResetBits(GPIOB, GPIO_Pin_12);\t//将PB12引脚设置为低电平，蜂鸣器鸣叫 Delay_ms(100);\t//延时100ms GPIO_SetBits(GPIOB, GPIO_Pin_12);\t//将PB12引脚设置为高电平，蜂鸣器停止 Delay_ms(700);\t//延时700ms } } 按键控制LED 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 //LED.c #include \u0026#34;stm32f10x.h\u0026#34; // Device header /** * 函 数：LED初始化 * 参 数：无 * 返 回 值：无 */ void LED_Init(void) { /*开启时钟*/ RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);\t//开启GPIOA的时钟 /*GPIO初始化*/ GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_2; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, \u0026amp;GPIO_InitStructure);\t//将PA1和PA2引脚初始化为推挽输出 /*设置GPIO初始化后的默认电平*/ GPIO_SetBits(GPIOA, GPIO_Pin_1 | GPIO_Pin_2);\t//设置PA1和PA2引脚为高电平 } /** * 函 数：LED1开启 * 参 数：无 * 返 回 值：无 */ void LED1_ON(void) { GPIO_ResetBits(GPIOA, GPIO_Pin_1);\t//设置PA1引脚为低电平 } /** * 函 数：LED1关闭 * 参 数：无 * 返 回 值：无 */ void LED1_OFF(void) { GPIO_SetBits(GPIOA, GPIO_Pin_1);\t//设置PA1引脚为高电平 } /** * 函 数：LED1状态翻转 * 参 数：无 * 返 回 值：无 */ void LED1_Turn(void) { if (GPIO_ReadOutputDataBit(GPIOA, GPIO_Pin_1) == 0)\t//获取输出寄存器的状态，如果当前引脚输出低电平 { GPIO_SetBits(GPIOA, GPIO_Pin_1);\t//则设置PA1引脚为高电平 } else\t//否则，即当前引脚输出高电平 { GPIO_ResetBits(GPIOA, GPIO_Pin_1);\t//则设置PA1引脚为低电平 } } /** * 函 数：LED2开启 * 参 数：无 * 返 回 值：无 */ void LED2_ON(void) { GPIO_ResetBits(GPIOA, GPIO_Pin_2);\t//设置PA2引脚为低电平 } /** * 函 数：LED2关闭 * 参 数：无 * 返 回 值：无 */ void LED2_OFF(void) { GPIO_SetBits(GPIOA, GPIO_Pin_2);\t//设置PA2引脚为高电平 } /** * 函 数：LED2状态翻转 * 参 数：无 * 返 回 值：无 */ void LED2_Turn(void) { if (GPIO_ReadOutputDataBit(GPIOA, GPIO_Pin_2) == 0)\t//获取输出寄存器的状态，如果当前引脚输出低电平 { GPIO_SetBits(GPIOA, GPIO_Pin_2); //则设置PA2引脚为高电平 } else //否则，即当前引脚输出高电平 { GPIO_ResetBits(GPIOA, GPIO_Pin_2); //则设置PA2引脚为低电平 } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 //Key.c #include \u0026#34;stm32f10x.h\u0026#34; // Device header #include \u0026#34;Delay.h\u0026#34; /** * 函 数：按键初始化 * 参 数：无 * 返 回 值：无 */ void Key_Init(void) { /*开启时钟*/ RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);\t//开启GPIOB的时钟 /*GPIO初始化*/ GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_11; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOB, \u0026amp;GPIO_InitStructure);\t//将PB1和PB11引脚初始化为上拉输入 } /** * 函 数：按键获取键码 * 参 数：无 * 返 回 值：按下按键的键码值，范围：0~2，返回0代表没有按键按下 * 注意事项：此函数是阻塞式操作，当按键按住不放时，函数会卡住，直到按键松手 */ uint8_t Key_GetNum(void) { uint8_t KeyNum = 0;\t//定义变量，默认键码值为0 if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1) == 0)\t//读PB1输入寄存器的状态，如果为0，则代表按键1按下 { Delay_ms(20);\t//延时消抖 while (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1) == 0);\t//等待按键松手 Delay_ms(20);\t//延时消抖 KeyNum = 1;\t//置键码为1 } if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_11) == 0)\t//读PB11输入寄存器的状态，如果为0，则代表按键2按下 { Delay_ms(20);\t//延时消抖 while (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_11) == 0);\t//等待按键松手 Delay_ms(20);\t//延时消抖 KeyNum = 2;\t//置键码为2 } return KeyNum;\t//返回键码值，如果没有按键按下，所有if都不成立，则键码为默认值0 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 //main.c #include \u0026#34;stm32f10x.h\u0026#34; // Device header #include \u0026#34;Delay.h\u0026#34; #include \u0026#34;LED.h\u0026#34; #include \u0026#34;Key.h\u0026#34; uint8_t KeyNum;\t//定义用于接收按键键码的变量 int main(void) { /*模块初始化*/ LED_Init();\t//LED初始化 Key_Init();\t//按键初始化 while (1) { KeyNum = Key_GetNum();\t//获取按键键码 if (KeyNum == 1)\t//按键1按下 { LED1_Turn();\t//LED1翻转 } if (KeyNum == 2)\t//按键2按下 { LED2_Turn();\t//LED2翻转 } } } 光敏传感器控制蜂鸣器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 //LightSensor #include \u0026#34;stm32f10x.h\u0026#34; // Device header /** * 函 数：光敏传感器初始化 * 参 数：无 * 返 回 值：无 */ void LightSensor_Init(void) { /*开启时钟*/ RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);\t//开启GPIOB的时钟 /*GPIO初始化*/ GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOB, \u0026amp;GPIO_InitStructure);\t//将PB13引脚初始化为上拉输入 } /** * 函 数：获取当前光敏传感器输出的高低电平 * 参 数：无 * 返 回 值：光敏传感器输出的高低电平，范围：0/1 */ uint8_t LightSensor_Get(void) { return GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_13);\t//返回PB13输入寄存器的状态 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 //Buzz.c #include \u0026#34;stm32f10x.h\u0026#34; // Device header /** * 函 数：蜂鸣器初始化 * 参 数：无 * 返 回 值：无 */ void Buzzer_Init(void) { /*开启时钟*/ RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);\t//开启GPIOB的时钟 /*GPIO初始化*/ GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOB, \u0026amp;GPIO_InitStructure);\t//将PB12引脚初始化为推挽输出 /*设置GPIO初始化后的默认电平*/ GPIO_SetBits(GPIOB, GPIO_Pin_12);\t//设置PB12引脚为高电平 } /** * 函 数：蜂鸣器开启 * 参 数：无 * 返 回 值：无 */ void Buzzer_ON(void) { GPIO_ResetBits(GPIOB, GPIO_Pin_12);\t//设置PB12引脚为低电平 } /** * 函 数：蜂鸣器关闭 * 参 数：无 * 返 回 值：无 */ void Buzzer_OFF(void) { GPIO_SetBits(GPIOB, GPIO_Pin_12);\t//设置PB12引脚为高电平 } /** * 函 数：蜂鸣器状态翻转 * 参 数：无 * 返 回 值：无 */ void Buzzer_Turn(void) { if (GPIO_ReadOutputDataBit(GPIOB, GPIO_Pin_12) == 0)\t//获取输出寄存器的状态，如果当前引脚输出低电平 { GPIO_SetBits(GPIOB, GPIO_Pin_12);\t//则设置PB12引脚为高电平 } else\t//否则，即当前引脚输出高电平 { GPIO_ResetBits(GPIOB, GPIO_Pin_12);\t//则设置PB12引脚为低电平 } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 //main.c #include \u0026#34;stm32f10x.h\u0026#34; // Device header #include \u0026#34;Delay.h\u0026#34; #include \u0026#34;Buzzer.h\u0026#34; #include \u0026#34;LightSensor.h\u0026#34; int main(void) { /*模块初始化*/ Buzzer_Init();\t//蜂鸣器初始化 LightSensor_Init();\t//光敏传感器初始化 while (1) { if (LightSensor_Get() == 1)\t//如果当前光敏输出1 { Buzzer_ON();\t//蜂鸣器开启 } else\t//否则 { Buzzer_OFF();\t//蜂鸣器关闭 } } } ","date":"2025-04-08T14:53:44+08:00","permalink":"https://ZCFZEUS.github.io/p/stm321-gpio/","title":"Stm32(1)-GPIO"},{"content":"变量类型与输出语句 编程基础 ⚫ 敲代码时切换到英文输入法，所有符号均为英文状态\n⚫ Python 的注释以 # 开头为标志，注释单独成行，或放在某语句右侧\n⚫ Python 是动态输入类型的语言，像 Matlab 一样，变量类型是动态推断的\n⚫静态类型的 C 语言须声明变量类型，如 int a = 1，而 Python 只需要 a =1\n⚫ 编程语言中的 a = 1 的含义是——将数值 1 赋给变量 a\n⚫ Python 里换行符（回车）可以替代分号（;），所以一般不出现分号\n⚫ Python 里四个空格是一个缩进，不要随意在某行代码的开头输入空格\n变量类型 ⚫ 像 C 语言和 Matlab 一样，变量名由字母、数字、下划线组成（但不能以数字开头），字母区分大小写，变量名不能与内置的函数同名\n⚫ 根据变量是否可以充当容器，将变量类型分为基本类型和高级类型\n基本变量类型：字符串、数字、布尔型\n高级变量类型：集合、元组、列表、字典\n七种变量类型，示例如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 字符串（str） str_v = \u0026#34;a real man\u0026#34; # 数字（int 或 float） num_v = 415411 # 布尔型（bool） bool_v = True # 集合（set） set_v = {1, 2, 3, 1} # 元组（tuple） tuple_v = (1, 2, 3) # 列表（list） list_v = [1, 2, 3] # 字典（dict） dict_v = {\u0026#39;a\u0026#39;:1, \u0026#39;b\u0026#39;:2 , \u0026#39;c\u0026#39;:3 } 输出语句 Python 语言的标准输出方法是：print(变量名)。Jupyter 中增加一种独特的输出方法，即在一个代码块内的最后一行写上变量名，即可输出该变量的数值。以上两种输出方法完全等效\nprint 函数的原理是输出仅一个单独的变量，它只有这一种用法，其它的各种用法要么是输出了f字符串，要么是输出了元组\n基本变量类型 字符串 字符串的结构 字符串用引号括起来，双引号和单引号都可以\n1 2 str1 = \u0026#39;A real man, he knows what he needs to do.\u0026#39; str2 = \u0026#34;A real man, he knows what he needs to do.\u0026#34; 当字符串变量内含有单引号，就用双引号来表示该字符串\n当字符串变量内含有双引号，就用单引号来表示该字符串\n1 2 str1 = \u0026#34;Jack\u0026#39;s book is in his home.\u0026#34; str2 = \u0026#39;He said \u0026#34;Rose\u0026#34;.\u0026#39; 输出语句的经典用法 想在字符串中插入其它变量，可使用“f字符串”的方法，代码示例如下\n1 2 3 4 str1 = \u0026#34;money path\u0026#34; str2 = \u0026#34;doctor\u0026#34; str3 = f\u0026#34;You ruined his {str1}. You ruined his {str2}.\u0026#34; str3 正是有了 f 字符串，才能实现如下输出，这也是 print 最常见的使用场景\n1 2 answer = 0.98 # 经过一系列运算，测试集给出准确率为 98% print(f\u0026#34;测试集的准确率为: {answer}\u0026#34;) 注意，这里的 print 依然只输出了一个单独的变量，即一个单独的 f 字符串\n输出语句的转义字符 在字符串中添加转义字符，如换行符\\n 与制表符\\t，可增加 print 的可读性。同时，转义字符只有在 print 里才能生效，单独对字符串使用无效\n1 2 3 4 5 6 # 构建字符串 message = \u0026#34;Shop sells:\\n\\tlitchi, \\n\\tfritters, \\n\\tfried fish.\u0026#34; # 单独输出字符串 message # 转义字符在 print 里生效 print(message) 数字 整数型数字和浮点型数字 数字有两种数据类型，分别是整数（int）和浮点数（float）。这里暂时不用太过区分二者，进入下一节《NumPy 数组库》时才要注意区分\n常用运算符 布尔型 布尔型只有两个值（True 和 False），通常是基于其它变量类型来进行生成\n基于基本变量类型生成 ⚫ 对字符串作比较，使用等于号==与不等号!= ⚫ 对数字作比较，使用大于\u0026gt;、大于等于\u0026gt;=、等于==、小于\u0026lt;、小于等于\u0026lt;=\n1 2 3 4 5 6 7 8 9 # 字符串——检查某字符串的值 str_v = \u0026#39;cxk\u0026#39; print(str_v == \u0026#39;chicken\u0026#39;) print(str_v != \u0026#39;chicken\u0026#39;) # 数字——检查某数字是否在某范围 num_v = 3 print(num_v \u0026gt; 5) print(num_v == 5) print(num_v \u0026lt; 5) 基于高级变量类型生成 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 集合——检查某变量是否在该集合中 set_v = {1, 2, 3} print(2 in set_v) print(2 not in set_v) # 元组——检查某变量是否在该元组中 tuple_v = (1, 2, 3) print(2 in tuple_v) print(2 not in tuple_v) # 列表——检查某变量是否在该列表中 list_v = [1, 2, 3] print(2 in list_v) print(2 not in list_v) # 字典——检查某变量是否在该字典中 dict _v = {\u0026#39;a\u0026#39;:1, \u0026#39;b\u0026#39;:2, \u0026#39;c\u0026#39;:3} print( 2 in dict _v.values() ) print( 2 not in dict _v.values() ) 同时检查多个条件 and 的规则是，两边全为 True 则为 True，其它情况均为 False or 的规则是，两边有一个是 True 则为 True，其他情况为 False\n1 2 3 4 5 6 7 # 先产生两个布尔值 T = True F = False # and 示例 T and F # or 示例 T or F 除了 and 和 or，还在一个布尔值前面加上 not，如 not True 就是 False\n判断语句 bool 值通常作为 if 判断的条件，if 判断的语法规则为\nif 布尔值:\n情况一\nelif 布尔值:\n情况二\nelse:\n其它情况\n注意事项：\n⚫ Python 的循环、判断、函数和类中均不使用 end 来表示代码块的结束\nPython 常常利用缩进（即四个空格）来表示代码块的范围\n每一个判断条件的最后有一个冒号，不要遗漏\n⚫ if 语句中，if:只出现 1 次，elif:可出现 0 至∞次，else:可出现 0 或 1 次\n示例如下:\n1 2 3 4 5 6 7 8 9 10 11 bool1 = False bool2 = False bool3 = False if bool1: print(\u0026#39;当 bool1 为 True，此行将被执行\u0026#39;) elif bool2: print(\u0026#39;否则的话，当 bool2 为 True，此行将被执行\u0026#39;) elif bool3: print(\u0026#39;否则的话，当 bool3 为 True，此行将被执行\u0026#39;) else: print(\u0026#39;否则的话，此行将被执行\u0026#39;) 基本变量间的转换 字符串、整数、浮点数、布尔型四者之间可以无缝切换\n⚫ 转换为字符串使用 str 函数\n⚫ 转换为整数型数字使用 int 函数\n⚫ 转换为浮点型数字使用 float 函数\n⚫ 转换为布尔型使用 bool 函数\n示例如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 定义变量 str_v = \u0026#39;123\u0026#39; int_v = 123 float_v = 123.0 bool_v = True # 转化为字符串 print( str( int_v ) ) print( str( float_v ) ) print( str( bool_v ) ) # 转化为整数型变量 print( int( str_v ) ) print( int( float_v ) ) print( int( bool_v ) ) # 转化为浮点型变量 print( float( str_v ) ) print( float( float_v ) ) print( float( bool_v ) ) # 转化为布尔型变量 print( bool( str_v ) ) print( bool( int_v ) ) print( bool( float_v ) ) 注：其它变量转为布尔型变量时，只有当字符串为空、数字为 0、集合为空、元组为空、列表为空、字典为空时，结果才为 False\n高级变量类型 高级变量类型，即集合、元组、列表、字典，它们有一个共同的特点：作为容器，它们可以随意容纳任意变量（甚至在同一个容器内包含 7 种变量类型）\n集合 集合是无序的、不可重复的元素的组合\n可以用两种方式创建集合：通过 set 函数或使用大括号，示例如下:\n1 2 3 4 # 使用 set()函数将列表转化为集合 set( [3,2,9,1,8,1,5,0,3,5] ) # 使用大括号创建 {\u0026#39;3\u0026#39;,\u0026#39;2\u0026#39;,\u0026#39;9\u0026#39;,\u0026#39;1\u0026#39;,\u0026#39;8\u0026#39;,\u0026#39;1\u0026#39;,\u0026#39;5\u0026#39;,\u0026#39;0\u0026#39;,\u0026#39;3\u0026#39;,\u0026#39;5\u0026#39;} 注意:请勿用大括号创建空集合，否则会被误认为是字典\n集合出现次数稀少，它更多的是被看作是字典的索引（即数据的标签）。后面会学习 Pandas 库，可替代集合\n元组 与列表不同!!!\n创建元组 有两种方式可以创建元组，一种是规范括号法，一种是省略括号法\n1 2 3 4 # 规范的括号法 (1, 2, 3) # 省略括号法（核心） 1, 2, 3 输出语句中的元组法 高级变量类型都可以容纳所有的变量类型，如示例所示:\n1 2 # 一个释放自我的元组 \u0026#39;a\u0026#39;, 1, True, {1,2,3},(1,2,3),[1,2,3],{\u0026#39;a\u0026#39;:1, \u0026#39;b\u0026#39;:2, \u0026#39;c\u0026#39;:3} 如果你在 print 里忽然见到逗号，不必大惊小怪，示例如下:\n1 2 3 4 # 元组法替代 f 字符串 answer = 98 print(f\u0026#39;最终答案为: {answer}\u0026#39;) # f 字符串法 print(\u0026#39;最终答案为: \u0026#39;, answer) # 元组法 缺点：输出的元素之间含有一个空格\n元组拆分法 1 2 3 4 5 6 7 8 9 10 11 # 元组拆分法——极速创建新变量 a,b,c = 1,2,3 print(c,b,a) # 元组拆分法——极速交换变量值 a,b = 1,2 b,a = a,b print(a,b) # 元组拆分法——只要前两个答案 values = 98, 99, 94, 94, 90, 92 a, b, *rest = values a, b, rest 列表 创建列表 列表由若干个有序的变量组成，其中的元素之间可以无任何关系。列表出现的标志是中括号，列表里的变量使用逗号分隔，示例如下：\n1 2 3 4 5 6 7 8 9 # 一个全是字符串的列表 list1 = [\u0026#39;Bro.chicken\u0026#39;, \u0026#39;30 months\u0026#39;, \u0026#39;Marry Pd\u0026#39;] list1 # 一个全是数字的列表 list2 = [11, 45, 14] list2 # 一个释放自我的列表 list3= [\u0026#39;cxk\u0026#39;, 666, True, set([1,2,3]), (1,2,3), [1,2,3], {\u0026#39;a\u0026#39;:1, \u0026#39;b\u0026#39;:2, \u0026#39;c\u0026#39;:3}] list3 列表可以容纳各种变量类型，其代价是——列表要单独存储 每一个元素的变量类型，列表越大越占空间。\n访问与修改某个元素 访问列表元素时使用中括号，索引由 0 开始，示例如下：\n1 2 3 list3 = [\u0026#39;cxk\u0026#39;, 666, True, set([1,2,3]), (1,2,3), [1,2,3], {\u0026#39;a\u0026#39;:1}] print(list3[0]) print(list3[5]) 当想访问列表倒数第一个元素时，可使用 a[-1]；当想访问倒数第二个元素，可使用 a[-2]；以此类推。代码示例如下：\n1 2 list4 = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] print( ( list4[-3] , list4[-2] , list4[-1] ) ) 可以通过访问某列表元素的方式对其数值进行修改。\n1 2 3 list4 = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] list4[-1] = 5 list4 切片——访问部分元素 切片，就是列表的一部分。如图所示\n当明确知道从第 x 个元素切到第 y 个元素，示例为\n1 2 3 4 5 list_v = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;] print( list_v ) print( list_v[ 1 : 4 ] ) # 从索引[1]开始，切到索引[4]之前 print( list_v[ 1 : ] ) # 从索引[1]开始，切到结尾 print( list_v[ : 4 ] ) # 从列表开头开始，切到索引[4]之前 当明确切除列表的开头与结尾，如示例所示\n1 2 3 4 5 list_v = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;] print( list_v ) print( list_v[ 2 : -2 ] ) # 切除开头 2 个和结尾 2 个 print( list_v[ : -2 ] ) # 切除结尾两个 print( list_v[ 2 : ] ) # 切除开头两个 当明确隔几个元素采样一次时，示例如下\n1 2 3 4 list_v = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;g\u0026#39;] print( list_v[ : : 2 ] ) # 每 2 个元素采样一次 print( list_v[ : : 3 ] ) # 每 3 个元素采样一次 print( list_v[ 1 : -1 : 2 ] ) # 切除一头一尾后，每 2 个元素采样一次 值得注意的是，对列表进行切片后得到一个新的对象，与原列表变量相互独立，如示例所示。但是若存储几百万条数据，这无疑对电脑是一种全新的考验\n1 2 3 4 5 6 7 8 9 # 创建 list_v 的切片 cut_v list_v = [1, 2, 3] cut_v = list_v[ 1 : ] cut_v # 修改 cut_v 的元素 cut_v[1] = \u0026#39;a\u0026#39; cut_v # 输出 list_v，其不受切片影响 list_v 列表元素的添加 列表可以使用 + 和 * 来添加原列表，示例如下\n1 2 3 4 5 list1 = [1,2,3] print( list1 + [4] ) # 列表尾部添加一个元素 print( list1 + [10,11,12] ) # 与另一个列表连接 print( list1 * 2 ) # 复制两倍的自己 print( list1 * 4 ) # 复制四倍的自己 字典 创建字典 字典可以理解为升级版的列表，每个元素的索引都可以自己定，示例如下:\n1 2 3 4 list_v = [ 90, 95, 100 ] dict_v = { \u0026#39;a\u0026#39;:90, \u0026#39;b\u0026#39;:95, \u0026#39;c\u0026#39;:100 } print( list_v[1] ) print( dict_v[\u0026#39;b\u0026#39;] ) 接下来创建一个与列表完全等效的特殊字典，如示例所示:\n1 2 3 4 list_v = [ 90, 95, 100 ] dict_v = { 0: 90, 1: 95, 2: 100 } print( list_v[1] ) print( dict_v[1] ) 字典中的元素值可以是任何变量，如示例所示:\n1 2 3 4 5 6 7 8 9 10 11 dict_v = { 0: \u0026#39;Chicken\u0026#39;, 1: 123, 2: True, 3: set([1,2,3]), 4: (1,2,3), 5: [1,2,3], 6: {\u0026#39;a\u0026#39;:1} } print ( dict_v[0], dict_v[1], dict_v[2], dict_v[3], dict_v[4], dict_v[5], dict_v[6]) 字典中的索引只能是数字或者字符串，且一般都是字符串\n注意：dict 作为 Python 的关键字和内置函数，变量名不建议命名为 dict,键一般是唯一的，如果重复最后的一个键值对会替换前面的，值不需要唯一。\n字典的每个键值 key:value 对用冒号 : 分割，每个键值对之间用逗号 , 分割，整个字典包括在花括号 {} 中,如示例所示:\n1 2 3 4 5 dict_v = { \u0026#39;zero\u0026#39; : 123, 1: True, } print( dict_v[\u0026#39;zero\u0026#39;], dict_v[1]) 字典的索引叫做“键”，字典的索引值叫“值”\n访问字典里的值 把相应的键放入熟悉的方括弧，如下实例:\n1 2 3 4 5 6 #!/usr/bin/python tinydict = {\u0026#39;Name\u0026#39;: \u0026#39;Zara\u0026#39;, \u0026#39;Age\u0026#39;: 7, \u0026#39;Class\u0026#39;: \u0026#39;First\u0026#39;} print \u0026#34;tinydict[\u0026#39;Name\u0026#39;]: \u0026#34;, tinydict[\u0026#39;Name\u0026#39;] print \u0026#34;tinydict[\u0026#39;Age\u0026#39;]: \u0026#34;, tinydict[\u0026#39;Age\u0026#39;] 字典元素的修改、添加与删除 向字典添加新内容的方法是增加新的键/值对如下实例:\n1 2 3 4 5 6 7 8 9 10 11 #!/usr/bin/python # -*- coding: UTF-8 -*- tinydict = {\u0026#39;Name\u0026#39;: \u0026#39;Zara\u0026#39;, \u0026#39;Age\u0026#39;: 7, \u0026#39;Class\u0026#39;: \u0026#39;First\u0026#39;} tinydict[\u0026#39;Age\u0026#39;] = 8 # 更新 tinydict[\u0026#39;School\u0026#39;] = \u0026#34;RUNOOB\u0026#34; # 添加 print \u0026#34;tinydict[\u0026#39;Age\u0026#39;]: \u0026#34;, tinydict[\u0026#39;Age\u0026#39;] print \u0026#34;tinydict[\u0026#39;School\u0026#39;]: \u0026#34;, tinydict[\u0026#39;School\u0026#39;] 能删单一的元素也能清空字典，清空只需一项操作。\n显示删除一个字典用del命令，如下实例：\n1 2 3 4 5 6 7 8 9 10 11 #!/usr/bin/python # -*- coding: UTF-8 -*- tinydict = {\u0026#39;Name\u0026#39;: \u0026#39;Zara\u0026#39;, \u0026#39;Age\u0026#39;: 7, \u0026#39;Class\u0026#39;: \u0026#39;First\u0026#39;} del tinydict[\u0026#39;Name\u0026#39;] # 删除键是\u0026#39;Name\u0026#39;的条目 tinydict.clear() # 清空字典所有条目 del tinydict # 删除字典 print \u0026#34;tinydict[\u0026#39;Age\u0026#39;]: \u0026#34;, tinydict[\u0026#39;Age\u0026#39;] print \u0026#34;tinydict[\u0026#39;School\u0026#39;]: \u0026#34;, tinydict[\u0026#39;School\u0026#39;] 循环语句 for 循环遍历列表 for 循环可以让循环变量依次取遍列表中的每个元素，其语法规则为\nfor 循环变量 in 列表:\n循环体\nfor 循环语句依托列表来进行循环，循环变量依次取遍列表中的元素,示例如下：\n1 2 3 4 5 6 7 8 9 10 11 #!/usr/bin/python # -*- coding: UTF-8 -*- for num in range(10,20): # 迭代 10 到 20 (不包含) 之间的数字 for i in range(2,num): # 根据因子迭代 if num%i == 0: # 确定第一个因子 j=num/i # 计算第二个因子 print (\u0026#39;%d 等于 %d * %d\u0026#39; % (num,i,j)) break # 跳出当前循环 else: # 循环的 else 部分 print (\u0026#39;%d 是一个质数\u0026#39; % num) for 循环遍历字典 for 循环遍历字典时，既可以遍历索引，也可以遍历值，更可以都遍历,示例如下：\n1 2 3 4 5 6 7 8 9 10 11 # 两电一邮的 A+学科 schools ={\u0026#39;成电\u0026#39;: \u0026#39;电科、信通\u0026#39;, \u0026#39;西电\u0026#39;: \u0026#39;电科\u0026#39;, \u0026#39;北邮\u0026#39;: \u0026#39;信通\u0026#39;} # 循环键 for k in schools.keys(): print( \u0026#39;两电一邮包括\u0026#39; , k ) # 循环值 for v in schools.values(): print( \u0026#39;A+学科是\u0026#39; , v ) # 循环键值对 for k, v in schools.items(): print( k, \u0026#39;的 A+学科是\u0026#39;, v ) 以上 print 输出的都是一个元组变量，用于替代 f 字符串\nwhile 循环 for 循环用于遍历高级变量类型中的元素，而 while 循环用于不断运行，直到布尔条件从 True 转为 False。其语法规则为\nwhile bool:\n循环体\n示例如下:\n1 2 3 4 a = 1 while a \u0026lt;= 5: print(a) a += 1 continue 与 break continue 用于中断本轮循环并进入下一轮循环，在 for 和 while 中均有效。\nbreak 用于停止循环，跳出循环后运行后续代码，在 for 和 while 中均有效。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # break 的演示 a = 1 while True: if a \u0026gt; 5: break print(a) a += 1 # continue 的演示 a = 0 while a \u0026lt; 5: a += 1 if a == 3: continue print(a) 列表推导式 基础用法如示例所示，这两种写法可以表达同一个意思:\n1 2 3 4 5 6 7 8 # 求平方——循环 value = [ ] for i in [1,2,3,4,5]: value = value + [i**2] print(value) # 求平方——列表推导式 value = [ i**2 for i in [1,2,3,4,5] ] print(value) 加一个 if 语句，如示例所示:\n1 2 3 4 5 6 7 8 9 # 求平方——循环 value = [ ] for i in [1,2,3,4,5]: if i \u0026lt; 4: value = value + [i**2] print(value) # 求平方——列表推导式 value = [ i**2 for i in [1,2,3,4,5] if i \u0026lt; 4 ] print(value) 高级变量间的转换 集合、元组、列表、字典四者之间可以无缝切换，需要用到四个函数\n⚫ 转换为集合使用 set 函数\n⚫ 转换为元组使用 tuple 函数\n⚫ 转换为列表使用 list 函数\n⚫ 转换为字典使用 dict 函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # 定义变量 set_v = {1,2,3} tuple_v = (1,2,3) list_v = [1,2,3] dict_v = { \u0026#39;a\u0026#39;:1 , \u0026#39;b\u0026#39;:2 , \u0026#39;c\u0026#39;:3 } # 转化为集合 print( set( tuple_v ) ) print( set( list_v ) ) print( set( dict_v.keys() ) ) print( set( dict_v.values() ) ) print( set( dict_v.items() ) ) # 转化为元组 print( tuple( set_v ) ) print( tuple( list_v ) ) print( tuple( dict_v.keys() ) ) print( tuple( dict_v.values() ) ) print( tuple( dict_v.items() ) ) # 转化为列表 print( list( set_v ) ) print( list( tuple_v ) ) print( list( dict_v.keys() ) ) print( list( dict_v.values() ) ) print( list( dict_v.items() ) ) # 转化为字典 print( dict( zip( {\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;} , set_v ) ) ) print( dict( zip( (\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;) , tuple_v ) ) ) print( dict( zip( [\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;] , list_v ) ) ) 注：在使用 dict 函数时，需搭配 zip 函数，zip 可将两个容器内的元素配对\n函数 函数可以避免大段的重复代码，其格式为\ndef 函数名(输入参数): \u0026rsquo;\u0026rsquo;\u0026rsquo; 文档字符串 \u0026rsquo;\u0026rsquo;' 函数体 return 输出参数\n文档字符串用于解释函数的作用，查看某函数文档字符串的方法是.doc。 第四行的 return 可省略（一般的函数不会省略），若省略，则返回 None\n吞吐各个类型的变量 函数的输入参数与输出参数均可以为任意的变量类型，示例如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 函数的输入与输出 def my_func(v): \u0026#39;\u0026#39;\u0026#39; 我的函数 \u0026#39;\u0026#39;\u0026#39; return v str_v = my_func( \u0026#34;cxk\u0026#34; ) # 字符串 str_v num_v = my_func( 123 ) # 数字 num_v bool_v = my_func( True ) # 布尔型 bool_v set_v = my_func( {1,2,3} ) # 集合 set_v tuple_v = my_func( (1,2,3) ) # 元组 tuple_v list_v = my_func( [1,2,3] ) # 列表 list_v dict_v = my_func( {\u0026#39;a\u0026#39;:1, \u0026#39;b\u0026#39;:2 , \u0026#39;c\u0026#39;:3 } ) # 字典 dict_v 函数内部的空间是独立的，函数内部的变量叫做形式参数，不影响外界的实际参数。在刚刚的例子中，In [1]函数体内的 v 就是形式参数，它在外界的实际空间中是不存在的，只在调用函数的过程中会在函数空间内临时存在\n吞吐多个变量 吞吐多个普通参数 输入多个值本质是输入了一个元组，输出多个值本质是输出了一个元组\n1 2 3 4 5 6 # 吞吐多个值（借助元组） def my_counter(a,b): \u0026#39;\u0026#39;\u0026#39;加法器和乘法器\u0026#39;\u0026#39;\u0026#39; return a+b, a*b x,y = my_counter(5,6) x,y 吞吐一个任意数量的参数 1 2 3 4 5 6 # 传入任意数量的参数（利用元组拆分法） def menu(*args): \u0026#39;\u0026#39;\u0026#39;菜单\u0026#39;\u0026#39;\u0026#39; return args info = menu(\u0026#39;荔枝\u0026#39;, \u0026#39;油饼\u0026#39;, \u0026#39;香精煎鱼\u0026#39;, \u0026#39;香翅捞饭\u0026#39;) info 吞吐多个普通参数，并附带一个任意数量的参数 普通参数与任意数量参数可以同时出现，但请把后者放在最右侧\n1 2 3 4 5 # 同时传入普通参数和任意数量的参数（后者只能出现一个） def her_hobbies(name, *hobbies): return name, hobbies n,h = her_hobbies(\u0026#39;cxk\u0026#39;, \u0026#39;singing\u0026#39;, \u0026#39;dancing\u0026#39;, \u0026#39;rap\u0026#39;, \u0026#39;basketball\u0026#39;) print( f\u0026#34;{n} likes {h}.\u0026#34; ) （4）吞吐多个普通参数，并附带一个任意数量的键值对参数 除了上述示例，甚至可以输入多个键值对，如下示例所示:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 对各专业评价 def evaluate(in1, in2, **kwargs): \u0026#39;\u0026#39;\u0026#39; 先对计算机类评价，再对通信类评价，也可自行补充 \u0026#39;\u0026#39;\u0026#39; kwargs [\u0026#39;计算机类\u0026#39;] = in1 kwargs [\u0026#39;通信工程\u0026#39;] = in2 return kwargs # 规矩评价法 eva1 = evaluate( \u0026#39;打代码的\u0026#39;, \u0026#39;拉网线的\u0026#39; ) eva1 # 额外补充法 eva2 = evaluate( \u0026#39;打代码的\u0026#39; , \u0026#39;拉网线的\u0026#39; , 电子工程 = \u0026#39;焊电路的\u0026#39; , 能源动力 = \u0026#39;烧锅炉的\u0026#39; ) eva2 在上述示例中，函数的输入形参 kwargs 的两个**会让 Python 创建一个名为kwargs 的空字典，并将键值对放入其中\n4.3 函数的关键字调用 函数可以顺序调用，也可以关键字调用，关键字方式更广泛，如示例所示:\n1 2 3 4 5 6 7 8 9 10 def my_evaluate1(college, major, evaluate): \u0026#39;\u0026#39;\u0026#39;对某大学某专业的评价\u0026#39;\u0026#39;\u0026#39; message = f\u0026#34;{college}的{major}{evaluate}。\u0026#34; return message # 顺序调用 info = my_evaluate1(\u0026#39;电子科技大学\u0026#39;, \u0026#39;自动化\u0026#39;, \u0026#39;挺厉害\u0026#39;) info # 关键字调用 info = my_evaluate1(\u0026#39;电子科技大学\u0026#39;, evaluate=\u0026#39;也还行\u0026#39;, major=\u0026#39;测控\u0026#39;) info 输入参数的默认值 如果有些参数绝大部分情况是不变的，那么可以给其设置一个默认值\n1 2 3 4 5 6 7 8 # 函数的默认值 def my_evaluate2(college, level=\u0026#39;带专\u0026#39;): message = f\u0026#34;{college}, 你是一所不错的{level}!\u0026#34; return message info = my_evaluate2(\u0026#39;电子科技大学\u0026#39;) # 遵循默认值 info info = my_evaluate2(\u0026#39;华中科技大学\u0026#39; , level=\u0026#39;985\u0026#39;) # 打破默认值 info 类 创建和使用类 ⚫ 类的本质：在一堆函数之间传递参数\n⚫ 根据约定，类的名称需要首字母大写\n⚫ 类中的函数叫方法，一个类包含一个__init__方法 + 很多自定义方法，__init__特殊方法前后均有两个下划线，每一个类中都必须包含此方法。示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 类的示范 class Counter: \u0026#39;\u0026#39;\u0026#39;一台可以加减的计算器\u0026#39;\u0026#39;\u0026#39; def __init__(self,a,b): # 特殊方法 \u0026#39;\u0026#39;\u0026#39; a 和 b 公共变量，也是 self 的属性\u0026#39;\u0026#39;\u0026#39; self.a = a # 公共变量 a 是 self 的属性 self.b = b # 公共变量 b 是 self 的属性 def add(self): # 自定义的加法方法 \u0026#39;\u0026#39;\u0026#39;加法\u0026#39;\u0026#39;\u0026#39; return self.a + self.b def sub(self): # 自定义的乘法方法 \u0026#39;\u0026#39;\u0026#39;减法\u0026#39;\u0026#39;\u0026#39; return self.a - self.b ⚫ 函数内部的变量与外部是在两个空间，为了使自定义方法能在类里互通，需要一个 self 作为舰船，将需要互通的变量作为 self 的属性进行传递；因此，特殊方法__init__旨在使用舰船 self 来承载公共变量 a 和 b\n⚫ __init__特殊方法后的括号里要写上舰船 self 以及公共变量 a 和 b，而自定义方法后的括号就只需要写舰船 self 即可\n1 2 3 4 # 创建类的实例 cnt = Counter(5,6) # 创建类的一个实例 cnt print( cnt.a, cnt.b ) # 访问属性 print( cnt.add() ) # 调用方法 属性的默认值 属性即公共变量，上一个实例里的属性即 a 和 b。可以给self 的属性一个默认值，此时默认值不用写进__init__后面的括号里\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 带有默认值的参数 class Man: \u0026#39;\u0026#39;\u0026#39;一个真正的 man\u0026#39;\u0026#39;\u0026#39; def __init__(self,name,age): \u0026#39;\u0026#39;\u0026#39;公共变量\u0026#39;\u0026#39;\u0026#39; self.name = name self.age = age self.gender = \u0026#39;man\u0026#39; # 一个带有默认值的属性 def zwjs(self): \u0026#39;\u0026#39;\u0026#39;自我介绍\u0026#39;\u0026#39;\u0026#39; print(f\u0026#34;大家好！我是{self.name}，今年{self.age}岁了！\u0026#34;) # 创建与使用类 cxk = Man(\u0026#39;鸡哥\u0026#39;,24) cxk.name, cxk.age # 访问属性 cxk.zwjs() # 调用方法 cxk.gender # 访问默认值 # 修改默认值的数值 cxk.gender = \u0026#39;Neither man nor woman\u0026#39; cxk.gender 继承 继承：在某个类（父类）的基础上添加几个方法，形成另一个类（子类）\n⚫ 父类从无到有去写属性和方法，第一行是 class 类名\n⚫ 子类可继承父类的属性和方法，第一行是 class 类名(父类名) :子类在特殊方法里使用super()函数，就可以继承到父类的全部属性与方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 # 父类（也就是前面的加减计算器） class Counter: \u0026#39;\u0026#39;\u0026#39;一台可以加减的计算器\u0026#39;\u0026#39;\u0026#39; def __init__(self,a,b): \u0026#39;\u0026#39;\u0026#39;公共变量\u0026#39;\u0026#39;\u0026#39; self.a = a self.b = b def add(self): \u0026#39;\u0026#39;\u0026#39;加法\u0026#39;\u0026#39;\u0026#39; return self.a + self.b def sub(self): \u0026#39;\u0026#39;\u0026#39;减法\u0026#39;\u0026#39;\u0026#39; return self.a - self.b # 子类（在加减的基础上，添加乘除功能） class Counter2(Counter): \u0026#39;\u0026#39;\u0026#39;一台可以加减乘除的高级计算器\u0026#39;\u0026#39;\u0026#39; def __init__(self,a,b): \u0026#39;\u0026#39;\u0026#39;引用父类的属性\u0026#39;\u0026#39;\u0026#39; super().__init__(a,b) # 继承父类（superclass） def mul(self): \u0026#39;\u0026#39;\u0026#39;乘法\u0026#39;\u0026#39;\u0026#39; return self.a * self.b def div(self): \u0026#39;\u0026#39;\u0026#39;除法\u0026#39;\u0026#39;\u0026#39; return self.a / self.b test = Counter2(3,4) print( test.sub() ) # 调用父类的方法 print( test.mul() ) # 调用自己的方法 如果想要在子类中修改父类中的某个方法，可以直接在子类里写一个同名方法，即可实现覆写，也可以把覆写说成“变异”\n掠夺 继承只能继承一个类的方法，但如果想要得到很多其它类的方法，则需要掠夺功能。有了掠夺功能，一个类可以掠夺很多其它的类，示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # 一个无辜的类 class Counter: \u0026#39;\u0026#39;\u0026#39;一台可以加减的计算器\u0026#39;\u0026#39;\u0026#39; def __init__(self,a,b): \u0026#39;\u0026#39;\u0026#39;公共变量\u0026#39;\u0026#39;\u0026#39; self.a = a self.b = b def add(self): \u0026#39;\u0026#39;\u0026#39;加法\u0026#39;\u0026#39;\u0026#39; return self.a + self.b def sub(self): \u0026#39;\u0026#39;\u0026#39;减法\u0026#39;\u0026#39;\u0026#39; return self.a - self.b # 掠夺者 class Amrc: \u0026#39;\u0026#39;\u0026#39;一台本身只能乘除的计算器，现欲掠夺加减功能\u0026#39;\u0026#39;\u0026#39; def __init__(self,c,d): \u0026#39;\u0026#39;\u0026#39;公共变量\u0026#39;\u0026#39;\u0026#39; self.c = c self.d = d self.cnt = Counter(c,d) # 掠夺 Counter 类的方法 def mul(self): \u0026#39;\u0026#39;\u0026#39;乘法\u0026#39;\u0026#39;\u0026#39; return self.c * self.d def div(self): \u0026#39;\u0026#39;\u0026#39;除法\u0026#39;\u0026#39;\u0026#39; return self.c / self.d 掠夺的本质是，将另一类的实例当作 self 的属性用，这样一来，被掠夺的类的数量就不设上限。此外，假如掠夺者和被掠夺者里都有 add 函数，掠夺者里的方法用 test.add()，被掠夺者里的方法用 test.cnt.add()，于是就不必覆写\n","date":"2025-04-06T18:09:35+08:00","permalink":"https://ZCFZEUS.github.io/p/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A01-python%E5%9F%BA%E7%A1%80/","title":"深度学习（1） Python基础"},{"content":"电阻应变片的种类 常按材料、工作温度范围及用途不同分类\n①按应变片敏感栅的材料分类，可将应变片分成金属应变片和半导体应变片两大类。\n② 按应变片的工作温度分类可分为常温应变片（20℃～60℃）、中温应变片（60℃～300℃）、高温应变片（300℃以上）和低温应变片（低于20℃）等。\n③按应变片的用途分类可分为一般用途应变片和特殊用途应变片（水下、疲劳寿命、抗磁感应、裂缝扩展等）。\n金属电阻应变片 结构 金属电阻应变片简称应变片，其结构大体相同，如图所示。由敏感栅、基底、覆盖层、引线和黏结剂等部分组成。\n敏感栅：实现应变-电阻转换的敏感元件，阻值一般在100Ω以上\n基底：粘贴、定位、绝缘，起着准确将试件应变传递到敏感栅的作用。为此，基底通常很薄，一般为0.02-0.04mm\n覆盖层：用纸或透明胶纸覆盖在敏感栅上，防潮、防尘、防蚀、防损\n引线：起敏感栅与测量电路间的过渡连接和引导作用\n黏结剂：传递应变\n分类 丝式应变片（分回线式和短接式两种） ① 回线式应变片:回线式应变片是将电阻丝绕制成栅粘在绝缘基片上制成的，如图4-2(a)\n特点：制作简单、性能稳定、价格便宜\n② 短接式应变片:短接式应变片是将数根等长的敏感金属丝平行放置，两端用直径比金属丝大5～10倍的镀银丝短接起来而构成的，如图4-2(b)\n优点：克服了回线式应变片的横向效应\n缺点：焊点多，易疲劳损坏\n箔式应变片 箔式应变片是将很薄的金属片粘于基片上，经光刻、腐蚀等制成金属箔敏感栅。给箔敏感栅接上金属丝电极，再涂覆与基片同质料的覆盖层。结构如图4-3所示\n优点：尺寸准确、线条均匀、可按需要做成各种形状、横向效应小、散热好、准确传递、薄、柔、寿命长、稳定性好\n缺点：灵敏度较低\n薄膜应变片 薄膜应变片是薄膜技术发展的产物。它是采用真空蒸发或真空沉积等方法，在薄的绝缘基片上形成厚度在0.1µm下的金属电阻材料薄膜的敏感栅，最后加上保护层。\n优点：应变灵敏系数大，允许电流密度大，工作范围广，温度可达197～371℃\n缺点：难以控制电阻与温度和时间的变化关系\n工作原理 参数 金属电阻应变片的主要参数有：\n（1）应变片电阻值R\n（2）灵敏系数k\n（3）机械滞后Zj\n（4）横向效应及横向效应系数H\n（5）零漂P和蠕变θ\n（6）绝缘电阻Rm\n应变片电阻值R:应变片没有粘贴及未参与变形前，室温下测定的电阻值称为初始电阻值，其中120Ω最常用，应变片电阻值的大小应与测量电阻相配合\n灵敏系数k：衡量应变片质量的重要标志\n机械滞后Zj：实际应用中，由于敏感栅基底和黏结剂材料性能，或者使用过程中的过载、过热，都会使应变计产生残余形变，导致应变片输出的不重合。这种不重合用机械滞后Zj来衡量。它是指粘贴在试件上的应变片，在恒温条件下增（加载）、减（卸载）试件应变的过程中，对应同一机械应变所指示应变量（输出）之差。通常，在室温条件下，要求机械滞后Zj \u0026lt; 3-10με。实测中，可在测试前通过多次重复预加、卸载，来减小机械滞后产生的误差\n横向效应及横向效应系数H\n横向效应：应变片在感受被测试件的应变时，横向应变将使其电阻变化率减小，从而降低灵敏系数，称为应变片的横向效应\n横向效应系数H：垂直时与平行时应变之比\n零漂P和蠕变θ\n零漂：温度恒定、试件初始空载时，应变片电阻值随时间变化的特性。两者之差即为零漂或稳定性误差。可用相对误差或绝对误差表示\n绝缘电阻Rm:略，懒得写了\n温度误差及其补偿 温度误差 温度补偿 单丝自补偿应变片 优点：结构简单，制造、使用方便\n缺点：一种αt值的应变片只能对应在一种材料上应用，局限性大\n双丝自补偿应变片 电桥补偿法 半导体应变片 半导体应变片的分类和结构 按照材料类型分为P型硅应变片、N型硅应变片、PN互补型应变片\n按照特性分为灵敏系数补偿型应变片和非线性补偿应变片\n按照材料的化学成分分为硅、锗、锑化铟、磷化镓、磷化铟等应变片\n目前应用较多的是按照结构分类，包括体型应变片、扩散型应变片和薄膜型半导体应变计\n半导体应变片的工作原理 优点：尺寸、横向效应、机械滞后都很小，灵敏系数极大，因而输出也大，可以不需要放大器直接与记录仪器连接，使得测量系统简化\n缺点：测量较大应变时非线性严重，灵敏系数随受拉或受压而变，且分散度大，一般为3%-5%\n电阻应变片的测量电路 电阻应变片把机械应变信号转换成后，由于应变量及其应变电阻变化一般都很微小，既难以直接精确测量，又不便直接处理，因此，必须采用转换电路或仪器，把应变片的变化转换成电压或电流变化。通常，采用电桥电路实现这种转换。\n直流电桥电路 直流电桥平衡条件 图4-6所示为直流电桥的基本电路，E为电桥电源电压，R1、R2、R3、R4为电桥的桥臂，RL为其负载（可以是测量仪表的内阻或其他负载）。\n电压灵敏度 非线性误差及其补偿方法 提高桥臂比 提高桥臂比可减小非线性误差。但是从电压灵敏度来考虑，提高桥臂比会降低电压灵敏度。因此，为达到既减小非线性误差又不降低电压灵敏度的目的，必须适当提高电源电压E\n采用差动电桥 根据被测试件的受力情况，在同一试件上分别粘贴两个应变片，一个感受拉力，另一个感受压力，两者应变符号相反，测试时，将两个应变片接入电桥的相邻臂上，如图4.7所示，称此电桥电路为半桥差动电路\n优点：差动电桥无非线性误差，而且电压灵敏度为Sv=0.5E,比使用一只应变片提高了1倍，同时可以起到温度补偿的作用\n给电桥的四臂接入4片应变片，使两个桥臂应变片受到拉力，两个桥臂应变片受到压力，将两个应变符号相同的接入相对桥臂上，则构成全桥差动电路。差动桥路的输出电压和电压灵敏度比单片提高了4倍，比半桥差动电路提高了1倍\n采用高内阻的恒流源电桥 产生非线性的原因之一是，在工作过程中通过桥臂的电流不恒定。所以有时用恒流电源供电。如图4-9所示。一般情况下，半导体应变电桥都采用恒流供电，供电电流为 ，通过各臂的电流分别为 和 ，如果测量电路的输入阻抗较高，则I1(R1+R2)=I2(R3+R4),I0=I1+I2,解方程可求得I1和I2\n","date":"2025-04-05T11:55:07+08:00","permalink":"https://ZCFZEUS.github.io/p/%E4%BC%A0%E6%84%9F%E5%99%A84.1-%E5%BA%94%E5%8F%98%E5%BC%8F%E7%94%B5%E9%98%BB%E4%BC%A0%E6%84%9F%E5%99%A8/","title":"传感器4.1 应变式电阻传感器"},{"content":" ","date":"2025-04-04T19:38:27+08:00","permalink":"https://ZCFZEUS.github.io/p/%E4%BC%A0%E6%84%9F%E5%99%A84.2-%E5%8E%8B%E7%94%B5%E5%BC%8F%E5%8A%9B%E4%BC%A0%E6%84%9F%E5%99%A8/","title":"传感器4.2 压电式力传感器"},{"content":"定义 顺序表——用顺序存储的方式实现线性表顺序存储。把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。 1 2 3 4 typedef struct { int num; //号数 int people; //人数 } Customer; 顺序表的实现 静态分配 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdio.h\u0026gt; #define MaxSize 10 //定义最大长度 typedef struct{ ElemType data[MaxSize]; //用静态的“数组”存放数据元素 int length; //顺序表的当前长度 }SqList; //顺序表的类型定义（静态分配方式） //基本操作-初始化一个顺序表 void InitList(SqList\u0026amp;L){ for(int i=0,i\u0026lt;MaxSize;i++) L.data[i] = 0;//将所有数据元素设置为默认值，否则内存中可能会有“脏数据” L.length = 0; } int main(){ SqList L; InitList(L); return 0; } 动态分配 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;stdlib.h\u0026gt; #define InitSize 10 //顺序表的初始长度 typedef struct{ ElemType *data; //指示动态分配数组的指针 int MaxSize; //顺序表的最大容量 int length; //顺序表的当前长度 } SeqList; //顺序表的类型定义（动态分配方式） void InitList(SqList\u0026amp;L){ L.data = (int *)malloc (InitSize*sizeof(int)); L.length = 0; L.MaxSize = InitSize; int main() { SqList L; InitList(L); return 0; } //延长： void IncreaseSize(SeList \u0026amp;L,int len){ int *p = L.data; L.data = (int *)malloc ((L.MaxSize+len)*sizeof(int)); for(int i=0,i\u0026lt;L.length;i++){ L.data[i] = p[i]; } L.MaxaSize += len; free(p);//释放原来内存空间 } } 总结 顺序表的特点：\n①随机访问，即可以在 O(1) 时间内找到第 i 个元素。\n②存储密度高，每个节点只存储数据元素\n③拓展容量不方便（即便采用动态分配的方式实现，拓展长度的时间复杂度也比较高）\n④插入、删除操作不方便，需要移动大量元素 ","date":"2025-04-02T22:47:03+08:00","permalink":"https://ZCFZEUS.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842.2-%E9%A1%BA%E5%BA%8F%E8%A1%A8/","title":"数据结构2.2-顺序表"},{"content":"定义 线性表是具有相同数据类型的n个数据元素的有限序列.\nn为表长，当n = 0时线性表是一个空表.\n若用L命名线性表，则其一般表示为,L = (a1, a2, … , ai, … , an).\n几个概念:\nai是线性表中的“第i个”元素线性表中的位序.\na1是表头元素；an是表尾元素.\n除第一个元素外，每个元素有且仅有一个直接前驱；除最后一个元素外，每个元素有且仅有一个直接后继.\n基本操作 InitList(\u0026amp;L):初始化表。构造一个空的线性表L，分配内存空间。\nDestroyList(\u0026amp;L)：销毁操作。销毁线性表，并释放线性表L所占用的内存空间。\nListInsert(\u0026amp;L,i,e)：插入操作。在表L中的第i个位置上插入指定元素e。\nListDelete(\u0026amp;L,i,\u0026amp;e)：删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。\nLocateElem(L,e)：按值查找操作。在表L中查找具有给定关键字值的元素。\nGetElem(L,i)：按位查找操作。获取表L中第i个位置的元素的值。\nLength(L)：求表长。返回线性表L的长度，即L中数据元素的个数。\nPrintList(L)：输出操作。按前后顺序输出线性表L的所有元素值。\nEmpty(L)：判空操作。若L为空表，则返回true，否则返回false。\n什么时候要传入参数的引用“\u0026amp;” —— 对参数的修改结果需要“带回来”.\n","date":"2025-04-02T22:03:49+08:00","permalink":"https://ZCFZEUS.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842.1-%E7%BA%BF%E6%80%A7%E8%A1%A8/","title":"数据结构2.1-线性表"}]