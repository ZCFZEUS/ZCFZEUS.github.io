[{"content":"变量类型与输出语句 编程基础 ⚫ 敲代码时切换到英文输入法，所有符号均为英文状态\n⚫ Python 的注释以 # 开头为标志，注释单独成行，或放在某语句右侧\n⚫ Python 是动态输入类型的语言，像 Matlab 一样，变量类型是动态推断的\n⚫静态类型的 C 语言须声明变量类型，如 int a = 1，而 Python 只需要 a =1\n⚫ 编程语言中的 a = 1 的含义是——将数值 1 赋给变量 a\n⚫ Python 里换行符（回车）可以替代分号（;），所以一般不出现分号\n⚫ Python 里四个空格是一个缩进，不要随意在某行代码的开头输入空格\n变量类型 ⚫ 像 C 语言和 Matlab 一样，变量名由字母、数字、下划线组成（但不能以数字开头），字母区分大小写，变量名不能与内置的函数同名\n⚫ 根据变量是否可以充当容器，将变量类型分为基本类型和高级类型\n基本变量类型：字符串、数字、布尔型\n高级变量类型：集合、元组、列表、字典\n七种变量类型，示例如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 字符串（str） str_v = \u0026#34;a real man\u0026#34; # 数字（int 或 float） num_v = 415411 # 布尔型（bool） bool_v = True # 集合（set） set_v = {1, 2, 3, 1} # 元组（tuple） tuple_v = (1, 2, 3) # 列表（list） list_v = [1, 2, 3] # 字典（dict） dict_v = {\u0026#39;a\u0026#39;:1, \u0026#39;b\u0026#39;:2 , \u0026#39;c\u0026#39;:3 } 输出语句 Python 语言的标准输出方法是：print(变量名)。Jupyter 中增加一种独特的输出方法，即在一个代码块内的最后一行写上变量名，即可输出该变量的数值。以上两种输出方法完全等效\nprint 函数的原理是输出仅一个单独的变量，它只有这一种用法，其它的各种用法要么是输出了f字符串，要么是输出了元组\n基本变量类型 字符串 字符串的结构 字符串用引号括起来，双引号和单引号都可以\n1 2 str1 = \u0026#39;A real man, he knows what he needs to do.\u0026#39; str2 = \u0026#34;A real man, he knows what he needs to do.\u0026#34; 当字符串变量内含有单引号，就用双引号来表示该字符串\n当字符串变量内含有双引号，就用单引号来表示该字符串\n1 2 str1 = \u0026#34;Jack\u0026#39;s book is in his home.\u0026#34; str2 = \u0026#39;He said \u0026#34;Rose\u0026#34;.\u0026#39; 输出语句的经典用法 想在字符串中插入其它变量，可使用“f字符串”的方法，代码示例如下\n1 2 3 4 str1 = \u0026#34;money path\u0026#34; str2 = \u0026#34;doctor\u0026#34; str3 = f\u0026#34;You ruined his {str1}. You ruined his {str2}.\u0026#34; str3 正是有了 f 字符串，才能实现如下输出，这也是 print 最常见的使用场景\n1 2 answer = 0.98 # 经过一系列运算，测试集给出准确率为 98% print(f\u0026#34;测试集的准确率为: {answer}\u0026#34;) 注意，这里的 print 依然只输出了一个单独的变量，即一个单独的 f 字符串\n输出语句的转义字符 在字符串中添加转义字符，如换行符\\n 与制表符\\t，可增加 print 的可读性。同时，转义字符只有在 print 里才能生效，单独对字符串使用无效\n1 2 3 4 5 6 # 构建字符串 message = \u0026#34;Shop sells:\\n\\tlitchi, \\n\\tfritters, \\n\\tfried fish.\u0026#34; # 单独输出字符串 message # 转义字符在 print 里生效 print(message) 数字 整数型数字和浮点型数字 数字有两种数据类型，分别是整数（int）和浮点数（float）。这里暂时不用太过区分二者，进入下一节《NumPy 数组库》时才要注意区分\n常用运算符 布尔型 布尔型只有两个值（True 和 False），通常是基于其它变量类型来进行生成\n基于基本变量类型生成 ⚫ 对字符串作比较，使用等于号==与不等号!= ⚫ 对数字作比较，使用大于\u0026gt;、大于等于\u0026gt;=、等于==、小于\u0026lt;、小于等于\u0026lt;=\n1 2 3 4 5 6 7 8 9 # 字符串——检查某字符串的值 str_v = \u0026#39;cxk\u0026#39; print(str_v == \u0026#39;chicken\u0026#39;) print(str_v != \u0026#39;chicken\u0026#39;) # 数字——检查某数字是否在某范围 num_v = 3 print(num_v \u0026gt; 5) print(num_v == 5) print(num_v \u0026lt; 5) 基于高级变量类型生成 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 集合——检查某变量是否在该集合中 set_v = {1, 2, 3} print(2 in set_v) print(2 not in set_v) # 元组——检查某变量是否在该元组中 tuple_v = (1, 2, 3) print(2 in tuple_v) print(2 not in tuple_v) # 列表——检查某变量是否在该列表中 list_v = [1, 2, 3] print(2 in list_v) print(2 not in list_v) # 字典——检查某变量是否在该字典中 dict _v = {\u0026#39;a\u0026#39;:1, \u0026#39;b\u0026#39;:2, \u0026#39;c\u0026#39;:3} print( 2 in dict _v.values() ) print( 2 not in dict _v.values() ) 同时检查多个条件 and 的规则是，两边全为 True 则为 True，其它情况均为 False or 的规则是，两边有一个是 True 则为 True，其他情况为 False\n1 2 3 4 5 6 7 # 先产生两个布尔值 T = True F = False # and 示例 T and F # or 示例 T or F 除了 and 和 or，还在一个布尔值前面加上 not，如 not True 就是 False\n判断语句 bool 值通常作为 if 判断的条件，if 判断的语法规则为\nif 布尔值:\n情况一\nelif 布尔值:\n情况二\nelse:\n其它情况\n注意事项：\n⚫ Python 的循环、判断、函数和类中均不使用 end 来表示代码块的结束\nPython 常常利用缩进（即四个空格）来表示代码块的范围\n每一个判断条件的最后有一个冒号，不要遗漏\n⚫ if 语句中，if:只出现 1 次，elif:可出现 0 至∞次，else:可出现 0 或 1 次\n示例如下:\n1 2 3 4 5 6 7 8 9 10 11 bool1 = False bool2 = False bool3 = False if bool1: print(\u0026#39;当 bool1 为 True，此行将被执行\u0026#39;) elif bool2: print(\u0026#39;否则的话，当 bool2 为 True，此行将被执行\u0026#39;) elif bool3: print(\u0026#39;否则的话，当 bool3 为 True，此行将被执行\u0026#39;) else: print(\u0026#39;否则的话，此行将被执行\u0026#39;) 基本变量间的转换 字符串、整数、浮点数、布尔型四者之间可以无缝切换\n⚫ 转换为字符串使用 str 函数\n⚫ 转换为整数型数字使用 int 函数\n⚫ 转换为浮点型数字使用 float 函数\n⚫ 转换为布尔型使用 bool 函数\n示例如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 定义变量 str_v = \u0026#39;123\u0026#39; int_v = 123 float_v = 123.0 bool_v = True # 转化为字符串 print( str( int_v ) ) print( str( float_v ) ) print( str( bool_v ) ) # 转化为整数型变量 print( int( str_v ) ) print( int( float_v ) ) print( int( bool_v ) ) # 转化为浮点型变量 print( float( str_v ) ) print( float( float_v ) ) print( float( bool_v ) ) # 转化为布尔型变量 print( bool( str_v ) ) print( bool( int_v ) ) print( bool( float_v ) ) 注：其它变量转为布尔型变量时，只有当字符串为空、数字为 0、集合为空、元组为空、列表为空、字典为空时，结果才为 False\n高级变量类型 高级变量类型，即集合、元组、列表、字典，它们有一个共同的特点：作为容器，它们可以随意容纳任意变量（甚至在同一个容器内包含 7 种变量类型）\n集合 集合是无序的、不可重复的元素的组合\n可以用两种方式创建集合：通过 set 函数或使用大括号，示例如下:\n1 2 3 4 # 使用 set()函数将列表转化为集合 set( [3,2,9,1,8,1,5,0,3,5] ) # 使用大括号创建 {\u0026#39;3\u0026#39;,\u0026#39;2\u0026#39;,\u0026#39;9\u0026#39;,\u0026#39;1\u0026#39;,\u0026#39;8\u0026#39;,\u0026#39;1\u0026#39;,\u0026#39;5\u0026#39;,\u0026#39;0\u0026#39;,\u0026#39;3\u0026#39;,\u0026#39;5\u0026#39;} 注意:请勿用大括号创建空集合，否则会被误认为是字典\n集合出现次数稀少，它更多的是被看作是字典的索引（即数据的标签）。后面会学习 Pandas 库，可替代集合\n元组 与列表不同!!!\n创建元组 有两种方式可以创建元组，一种是规范括号法，一种是省略括号法\n1 2 3 4 # 规范的括号法 (1, 2, 3) # 省略括号法（核心） 1, 2, 3 输出语句中的元组法 高级变量类型都可以容纳所有的变量类型，如示例所示:\n1 2 # 一个释放自我的元组 \u0026#39;a\u0026#39;, 1, True, {1,2,3},(1,2,3),[1,2,3],{\u0026#39;a\u0026#39;:1, \u0026#39;b\u0026#39;:2, \u0026#39;c\u0026#39;:3} 如果你在 print 里忽然见到逗号，不必大惊小怪，示例如下:\n1 2 3 4 # 元组法替代 f 字符串 answer = 98 print(f\u0026#39;最终答案为: {answer}\u0026#39;) # f 字符串法 print(\u0026#39;最终答案为: \u0026#39;, answer) # 元组法 缺点：输出的元素之间含有一个空格\n元组拆分法 1 2 3 4 5 6 7 8 9 10 11 # 元组拆分法——极速创建新变量 a,b,c = 1,2,3 print(c,b,a) # 元组拆分法——极速交换变量值 a,b = 1,2 b,a = a,b print(a,b) # 元组拆分法——只要前两个答案 values = 98, 99, 94, 94, 90, 92 a, b, *rest = values a, b, rest 列表 创建列表 列表由若干个有序的变量组成，其中的元素之间可以无任何关系。列表出现的标志是中括号，列表里的变量使用逗号分隔，示例如下：\n1 2 3 4 5 6 7 8 9 # 一个全是字符串的列表 list1 = [\u0026#39;Bro.chicken\u0026#39;, \u0026#39;30 months\u0026#39;, \u0026#39;Marry Pd\u0026#39;] list1 # 一个全是数字的列表 list2 = [11, 45, 14] list2 # 一个释放自我的列表 list3= [\u0026#39;cxk\u0026#39;, 666, True, set([1,2,3]), (1,2,3), [1,2,3], {\u0026#39;a\u0026#39;:1, \u0026#39;b\u0026#39;:2, \u0026#39;c\u0026#39;:3}] list3 列表可以容纳各种变量类型，其代价是——列表要单独存储 每一个元素的变量类型，列表越大越占空间。\n访问与修改某个元素 访问列表元素时使用中括号，索引由 0 开始，示例如下：\n1 2 3 list3 = [\u0026#39;cxk\u0026#39;, 666, True, set([1,2,3]), (1,2,3), [1,2,3], {\u0026#39;a\u0026#39;:1}] print(list3[0]) print(list3[5]) 当想访问列表倒数第一个元素时，可使用 a[-1]；当想访问倒数第二个元素，可使用 a[-2]；以此类推。代码示例如下：\n1 2 list4 = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] print( ( list4[-3] , list4[-2] , list4[-1] ) ) 可以通过访问某列表元素的方式对其数值进行修改。\n1 2 3 list4 = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] list4[-1] = 5 list4 切片——访问部分元素 切片，就是列表的一部分。如图所示\n当明确知道从第 x 个元素切到第 y 个元素，示例为\n1 2 3 4 5 list_v = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;] print( list_v ) print( list_v[ 1 : 4 ] ) # 从索引[1]开始，切到索引[4]之前 print( list_v[ 1 : ] ) # 从索引[1]开始，切到结尾 print( list_v[ : 4 ] ) # 从列表开头开始，切到索引[4]之前 当明确切除列表的开头与结尾，如示例所示\n1 2 3 4 5 list_v = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;] print( list_v ) print( list_v[ 2 : -2 ] ) # 切除开头 2 个和结尾 2 个 print( list_v[ : -2 ] ) # 切除结尾两个 print( list_v[ 2 : ] ) # 切除开头两个 当明确隔几个元素采样一次时，示例如下\n1 2 3 4 list_v = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;g\u0026#39;] print( list_v[ : : 2 ] ) # 每 2 个元素采样一次 print( list_v[ : : 3 ] ) # 每 3 个元素采样一次 print( list_v[ 1 : -1 : 2 ] ) # 切除一头一尾后，每 2 个元素采样一次 值得注意的是，对列表进行切片后得到一个新的对象，与原列表变量相互独立，如示例所示。但是若存储几百万条数据，这无疑对电脑是一种全新的考验\n1 2 3 4 5 6 7 8 9 # 创建 list_v 的切片 cut_v list_v = [1, 2, 3] cut_v = list_v[ 1 : ] cut_v # 修改 cut_v 的元素 cut_v[1] = \u0026#39;a\u0026#39; cut_v # 输出 list_v，其不受切片影响 list_v 列表元素的添加 列表可以使用 + 和 * 来添加原列表，示例如下\n1 2 3 4 5 list1 = [1,2,3] print( list1 + [4] ) # 列表尾部添加一个元素 print( list1 + [10,11,12] ) # 与另一个列表连接 print( list1 * 2 ) # 复制两倍的自己 print( list1 * 4 ) # 复制四倍的自己 字典 创建字典 字典可以理解为升级版的列表，每个元素的索引都可以自己定，示例如下:\n1 2 3 4 list_v = [ 90, 95, 100 ] dict_v = { \u0026#39;a\u0026#39;:90, \u0026#39;b\u0026#39;:95, \u0026#39;c\u0026#39;:100 } print( list_v[1] ) print( dict_v[\u0026#39;b\u0026#39;] ) 接下来创建一个与列表完全等效的特殊字典，如示例所示:\n1 2 3 4 list_v = [ 90, 95, 100 ] dict_v = { 0: 90, 1: 95, 2: 100 } print( list_v[1] ) print( dict_v[1] ) 字典中的元素值可以是任何变量，如示例所示:\n1 2 3 4 5 6 7 8 9 10 11 dict_v = { 0: \u0026#39;Chicken\u0026#39;, 1: 123, 2: True, 3: set([1,2,3]), 4: (1,2,3), 5: [1,2,3], 6: {\u0026#39;a\u0026#39;:1} } print ( dict_v[0], dict_v[1], dict_v[2], dict_v[3], dict_v[4], dict_v[5], dict_v[6]) 字典中的索引只能是数字或者字符串，且一般都是字符串\n注意：dict 作为 Python 的关键字和内置函数，变量名不建议命名为 dict,键一般是唯一的，如果重复最后的一个键值对会替换前面的，值不需要唯一。\n字典的每个键值 key:value 对用冒号 : 分割，每个键值对之间用逗号 , 分割，整个字典包括在花括号 {} 中,如示例所示:\n1 2 3 4 5 dict_v = { \u0026#39;zero\u0026#39; : 123, 1: True, } print( dict_v[\u0026#39;zero\u0026#39;], dict_v[1]) 字典的索引叫做“键”，字典的索引值叫“值”\n访问字典里的值 把相应的键放入熟悉的方括弧，如下实例:\n1 2 3 4 5 6 #!/usr/bin/python tinydict = {\u0026#39;Name\u0026#39;: \u0026#39;Zara\u0026#39;, \u0026#39;Age\u0026#39;: 7, \u0026#39;Class\u0026#39;: \u0026#39;First\u0026#39;} print \u0026#34;tinydict[\u0026#39;Name\u0026#39;]: \u0026#34;, tinydict[\u0026#39;Name\u0026#39;] print \u0026#34;tinydict[\u0026#39;Age\u0026#39;]: \u0026#34;, tinydict[\u0026#39;Age\u0026#39;] 字典元素的修改、添加与删除 向字典添加新内容的方法是增加新的键/值对如下实例:\n1 2 3 4 5 6 7 8 9 10 11 #!/usr/bin/python # -*- coding: UTF-8 -*- tinydict = {\u0026#39;Name\u0026#39;: \u0026#39;Zara\u0026#39;, \u0026#39;Age\u0026#39;: 7, \u0026#39;Class\u0026#39;: \u0026#39;First\u0026#39;} tinydict[\u0026#39;Age\u0026#39;] = 8 # 更新 tinydict[\u0026#39;School\u0026#39;] = \u0026#34;RUNOOB\u0026#34; # 添加 print \u0026#34;tinydict[\u0026#39;Age\u0026#39;]: \u0026#34;, tinydict[\u0026#39;Age\u0026#39;] print \u0026#34;tinydict[\u0026#39;School\u0026#39;]: \u0026#34;, tinydict[\u0026#39;School\u0026#39;] 能删单一的元素也能清空字典，清空只需一项操作。\n显示删除一个字典用del命令，如下实例：\n1 2 3 4 5 6 7 8 9 10 11 #!/usr/bin/python # -*- coding: UTF-8 -*- tinydict = {\u0026#39;Name\u0026#39;: \u0026#39;Zara\u0026#39;, \u0026#39;Age\u0026#39;: 7, \u0026#39;Class\u0026#39;: \u0026#39;First\u0026#39;} del tinydict[\u0026#39;Name\u0026#39;] # 删除键是\u0026#39;Name\u0026#39;的条目 tinydict.clear() # 清空字典所有条目 del tinydict # 删除字典 print \u0026#34;tinydict[\u0026#39;Age\u0026#39;]: \u0026#34;, tinydict[\u0026#39;Age\u0026#39;] print \u0026#34;tinydict[\u0026#39;School\u0026#39;]: \u0026#34;, tinydict[\u0026#39;School\u0026#39;] 循环语句 for 循环遍历列表 for 循环可以让循环变量依次取遍列表中的每个元素，其语法规则为\nfor 循环变量 in 列表:\n循环体\nfor 循环语句依托列表来进行循环，循环变量依次取遍列表中的元素,示例如下：\n1 2 3 4 5 6 7 8 9 10 11 #!/usr/bin/python # -*- coding: UTF-8 -*- for num in range(10,20): # 迭代 10 到 20 (不包含) 之间的数字 for i in range(2,num): # 根据因子迭代 if num%i == 0: # 确定第一个因子 j=num/i # 计算第二个因子 print (\u0026#39;%d 等于 %d * %d\u0026#39; % (num,i,j)) break # 跳出当前循环 else: # 循环的 else 部分 print (\u0026#39;%d 是一个质数\u0026#39; % num) for 循环遍历字典 for 循环遍历字典时，既可以遍历索引，也可以遍历值，更可以都遍历,示例如下：\n1 2 3 4 5 6 7 8 9 10 11 # 两电一邮的 A+学科 schools ={\u0026#39;成电\u0026#39;: \u0026#39;电科、信通\u0026#39;, \u0026#39;西电\u0026#39;: \u0026#39;电科\u0026#39;, \u0026#39;北邮\u0026#39;: \u0026#39;信通\u0026#39;} # 循环键 for k in schools.keys(): print( \u0026#39;两电一邮包括\u0026#39; , k ) # 循环值 for v in schools.values(): print( \u0026#39;A+学科是\u0026#39; , v ) # 循环键值对 for k, v in schools.items(): print( k, \u0026#39;的 A+学科是\u0026#39;, v ) 以上 print 输出的都是一个元组变量，用于替代 f 字符串\nwhile 循环 for 循环用于遍历高级变量类型中的元素，而 while 循环用于不断运行，直到布尔条件从 True 转为 False。其语法规则为\nwhile bool:\n循环体\n示例如下:\n1 2 3 4 a = 1 while a \u0026lt;= 5: print(a) a += 1 continue 与 break continue 用于中断本轮循环并进入下一轮循环，在 for 和 while 中均有效。\nbreak 用于停止循环，跳出循环后运行后续代码，在 for 和 while 中均有效。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # break 的演示 a = 1 while True: if a \u0026gt; 5: break print(a) a += 1 # continue 的演示 a = 0 while a \u0026lt; 5: a += 1 if a == 3: continue print(a) 列表推导式 基础用法如示例所示，这两种写法可以表达同一个意思:\n1 2 3 4 5 6 7 8 # 求平方——循环 value = [ ] for i in [1,2,3,4,5]: value = value + [i**2] print(value) # 求平方——列表推导式 value = [ i**2 for i in [1,2,3,4,5] ] print(value) 加一个 if 语句，如示例所示:\n1 2 3 4 5 6 7 8 9 # 求平方——循环 value = [ ] for i in [1,2,3,4,5]: if i \u0026lt; 4: value = value + [i**2] print(value) # 求平方——列表推导式 value = [ i**2 for i in [1,2,3,4,5] if i \u0026lt; 4 ] print(value) 高级变量间的转换 集合、元组、列表、字典四者之间可以无缝切换，需要用到四个函数\n⚫ 转换为集合使用 set 函数\n⚫ 转换为元组使用 tuple 函数\n⚫ 转换为列表使用 list 函数\n⚫ 转换为字典使用 dict 函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # 定义变量 set_v = {1,2,3} tuple_v = (1,2,3) list_v = [1,2,3] dict_v = { \u0026#39;a\u0026#39;:1 , \u0026#39;b\u0026#39;:2 , \u0026#39;c\u0026#39;:3 } # 转化为集合 print( set( tuple_v ) ) print( set( list_v ) ) print( set( dict_v.keys() ) ) print( set( dict_v.values() ) ) print( set( dict_v.items() ) ) # 转化为元组 print( tuple( set_v ) ) print( tuple( list_v ) ) print( tuple( dict_v.keys() ) ) print( tuple( dict_v.values() ) ) print( tuple( dict_v.items() ) ) # 转化为列表 print( list( set_v ) ) print( list( tuple_v ) ) print( list( dict_v.keys() ) ) print( list( dict_v.values() ) ) print( list( dict_v.items() ) ) # 转化为字典 print( dict( zip( {\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;} , set_v ) ) ) print( dict( zip( (\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;) , tuple_v ) ) ) print( dict( zip( [\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;] , list_v ) ) ) 注：在使用 dict 函数时，需搭配 zip 函数，zip 可将两个容器内的元素配对\n函数 函数可以避免大段的重复代码，其格式为\ndef 函数名(输入参数): \u0026rsquo;\u0026rsquo;\u0026rsquo; 文档字符串 \u0026rsquo;\u0026rsquo;' 函数体 return 输出参数\n文档字符串用于解释函数的作用，查看某函数文档字符串的方法是.doc。 第四行的 return 可省略（一般的函数不会省略），若省略，则返回 None\n吞吐各个类型的变量 函数的输入参数与输出参数均可以为任意的变量类型，示例如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 函数的输入与输出 def my_func(v): \u0026#39;\u0026#39;\u0026#39; 我的函数 \u0026#39;\u0026#39;\u0026#39; return v str_v = my_func( \u0026#34;cxk\u0026#34; ) # 字符串 str_v num_v = my_func( 123 ) # 数字 num_v bool_v = my_func( True ) # 布尔型 bool_v set_v = my_func( {1,2,3} ) # 集合 set_v tuple_v = my_func( (1,2,3) ) # 元组 tuple_v list_v = my_func( [1,2,3] ) # 列表 list_v dict_v = my_func( {\u0026#39;a\u0026#39;:1, \u0026#39;b\u0026#39;:2 , \u0026#39;c\u0026#39;:3 } ) # 字典 dict_v 函数内部的空间是独立的，函数内部的变量叫做形式参数，不影响外界的实际参数。在刚刚的例子中，In [1]函数体内的 v 就是形式参数，它在外界的实际空间中是不存在的，只在调用函数的过程中会在函数空间内临时存在\n吞吐多个变量 吞吐多个普通参数 输入多个值本质是输入了一个元组，输出多个值本质是输出了一个元组\n1 2 3 4 5 6 # 吞吐多个值（借助元组） def my_counter(a,b): \u0026#39;\u0026#39;\u0026#39;加法器和乘法器\u0026#39;\u0026#39;\u0026#39; return a+b, a*b x,y = my_counter(5,6) x,y 吞吐一个任意数量的参数 1 2 3 4 5 6 # 传入任意数量的参数（利用元组拆分法） def menu(*args): \u0026#39;\u0026#39;\u0026#39;菜单\u0026#39;\u0026#39;\u0026#39; return args info = menu(\u0026#39;荔枝\u0026#39;, \u0026#39;油饼\u0026#39;, \u0026#39;香精煎鱼\u0026#39;, \u0026#39;香翅捞饭\u0026#39;) info 吞吐多个普通参数，并附带一个任意数量的参数 普通参数与任意数量参数可以同时出现，但请把后者放在最右侧\n1 2 3 4 5 # 同时传入普通参数和任意数量的参数（后者只能出现一个） def her_hobbies(name, *hobbies): return name, hobbies n,h = her_hobbies(\u0026#39;cxk\u0026#39;, \u0026#39;singing\u0026#39;, \u0026#39;dancing\u0026#39;, \u0026#39;rap\u0026#39;, \u0026#39;basketball\u0026#39;) print( f\u0026#34;{n} likes {h}.\u0026#34; ) （4）吞吐多个普通参数，并附带一个任意数量的键值对参数 除了上述示例，甚至可以输入多个键值对，如下示例所示:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 对各专业评价 def evaluate(in1, in2, **kwargs): \u0026#39;\u0026#39;\u0026#39; 先对计算机类评价，再对通信类评价，也可自行补充 \u0026#39;\u0026#39;\u0026#39; kwargs [\u0026#39;计算机类\u0026#39;] = in1 kwargs [\u0026#39;通信工程\u0026#39;] = in2 return kwargs # 规矩评价法 eva1 = evaluate( \u0026#39;打代码的\u0026#39;, \u0026#39;拉网线的\u0026#39; ) eva1 # 额外补充法 eva2 = evaluate( \u0026#39;打代码的\u0026#39; , \u0026#39;拉网线的\u0026#39; , 电子工程 = \u0026#39;焊电路的\u0026#39; , 能源动力 = \u0026#39;烧锅炉的\u0026#39; ) eva2 在上述示例中，函数的输入形参 kwargs 的两个**会让 Python 创建一个名为kwargs 的空字典，并将键值对放入其中\n4.3 函数的关键字调用 函数可以顺序调用，也可以关键字调用，关键字方式更广泛，如示例所示:\n1 2 3 4 5 6 7 8 9 10 def my_evaluate1(college, major, evaluate): \u0026#39;\u0026#39;\u0026#39;对某大学某专业的评价\u0026#39;\u0026#39;\u0026#39; message = f\u0026#34;{college}的{major}{evaluate}。\u0026#34; return message # 顺序调用 info = my_evaluate1(\u0026#39;电子科技大学\u0026#39;, \u0026#39;自动化\u0026#39;, \u0026#39;挺厉害\u0026#39;) info # 关键字调用 info = my_evaluate1(\u0026#39;电子科技大学\u0026#39;, evaluate=\u0026#39;也还行\u0026#39;, major=\u0026#39;测控\u0026#39;) info 输入参数的默认值 如果有些参数绝大部分情况是不变的，那么可以给其设置一个默认值\n1 2 3 4 5 6 7 8 # 函数的默认值 def my_evaluate2(college, level=\u0026#39;带专\u0026#39;): message = f\u0026#34;{college}, 你是一所不错的{level}!\u0026#34; return message info = my_evaluate2(\u0026#39;电子科技大学\u0026#39;) # 遵循默认值 info info = my_evaluate2(\u0026#39;华中科技大学\u0026#39; , level=\u0026#39;985\u0026#39;) # 打破默认值 info 类 创建和使用类 ⚫ 类的本质：在一堆函数之间传递参数\n⚫ 根据约定，类的名称需要首字母大写\n⚫ 类中的函数叫方法，一个类包含一个__init__方法 + 很多自定义方法，__init__特殊方法前后均有两个下划线，每一个类中都必须包含此方法。示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 类的示范 class Counter: \u0026#39;\u0026#39;\u0026#39;一台可以加减的计算器\u0026#39;\u0026#39;\u0026#39; def __init__(self,a,b): # 特殊方法 \u0026#39;\u0026#39;\u0026#39; a 和 b 公共变量，也是 self 的属性\u0026#39;\u0026#39;\u0026#39; self.a = a # 公共变量 a 是 self 的属性 self.b = b # 公共变量 b 是 self 的属性 def add(self): # 自定义的加法方法 \u0026#39;\u0026#39;\u0026#39;加法\u0026#39;\u0026#39;\u0026#39; return self.a + self.b def sub(self): # 自定义的乘法方法 \u0026#39;\u0026#39;\u0026#39;减法\u0026#39;\u0026#39;\u0026#39; return self.a - self.b ⚫ 函数内部的变量与外部是在两个空间，为了使自定义方法能在类里互通，需要一个 self 作为舰船，将需要互通的变量作为 self 的属性进行传递；因此，特殊方法__init__旨在使用舰船 self 来承载公共变量 a 和 b\n⚫ __init__特殊方法后的括号里要写上舰船 self 以及公共变量 a 和 b，而自定义方法后的括号就只需要写舰船 self 即可\n1 2 3 4 # 创建类的实例 cnt = Counter(5,6) # 创建类的一个实例 cnt print( cnt.a, cnt.b ) # 访问属性 print( cnt.add() ) # 调用方法 属性的默认值 属性即公共变量，上一个实例里的属性即 a 和 b。可以给self 的属性一个默认值，此时默认值不用写进__init__后面的括号里\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 带有默认值的参数 class Man: \u0026#39;\u0026#39;\u0026#39;一个真正的 man\u0026#39;\u0026#39;\u0026#39; def __init__(self,name,age): \u0026#39;\u0026#39;\u0026#39;公共变量\u0026#39;\u0026#39;\u0026#39; self.name = name self.age = age self.gender = \u0026#39;man\u0026#39; # 一个带有默认值的属性 def zwjs(self): \u0026#39;\u0026#39;\u0026#39;自我介绍\u0026#39;\u0026#39;\u0026#39; print(f\u0026#34;大家好！我是{self.name}，今年{self.age}岁了！\u0026#34;) # 创建与使用类 cxk = Man(\u0026#39;鸡哥\u0026#39;,24) cxk.name, cxk.age # 访问属性 cxk.zwjs() # 调用方法 cxk.gender # 访问默认值 # 修改默认值的数值 cxk.gender = \u0026#39;Neither man nor woman\u0026#39; cxk.gender 继承 继承：在某个类（父类）的基础上添加几个方法，形成另一个类（子类）\n⚫ 父类从无到有去写属性和方法，第一行是 class 类名\n⚫ 子类可继承父类的属性和方法，第一行是 class 类名(父类名) :子类在特殊方法里使用super()函数，就可以继承到父类的全部属性与方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 # 父类（也就是前面的加减计算器） class Counter: \u0026#39;\u0026#39;\u0026#39;一台可以加减的计算器\u0026#39;\u0026#39;\u0026#39; def __init__(self,a,b): \u0026#39;\u0026#39;\u0026#39;公共变量\u0026#39;\u0026#39;\u0026#39; self.a = a self.b = b def add(self): \u0026#39;\u0026#39;\u0026#39;加法\u0026#39;\u0026#39;\u0026#39; return self.a + self.b def sub(self): \u0026#39;\u0026#39;\u0026#39;减法\u0026#39;\u0026#39;\u0026#39; return self.a - self.b # 子类（在加减的基础上，添加乘除功能） class Counter2(Counter): \u0026#39;\u0026#39;\u0026#39;一台可以加减乘除的高级计算器\u0026#39;\u0026#39;\u0026#39; def __init__(self,a,b): \u0026#39;\u0026#39;\u0026#39;引用父类的属性\u0026#39;\u0026#39;\u0026#39; super().__init__(a,b) # 继承父类（superclass） def mul(self): \u0026#39;\u0026#39;\u0026#39;乘法\u0026#39;\u0026#39;\u0026#39; return self.a * self.b def div(self): \u0026#39;\u0026#39;\u0026#39;除法\u0026#39;\u0026#39;\u0026#39; return self.a / self.b test = Counter2(3,4) print( test.sub() ) # 调用父类的方法 print( test.mul() ) # 调用自己的方法 如果想要在子类中修改父类中的某个方法，可以直接在子类里写一个同名方法，即可实现覆写，也可以把覆写说成“变异”\n掠夺 继承只能继承一个类的方法，但如果想要得到很多其它类的方法，则需要掠夺功能。有了掠夺功能，一个类可以掠夺很多其它的类，示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # 一个无辜的类 class Counter: \u0026#39;\u0026#39;\u0026#39;一台可以加减的计算器\u0026#39;\u0026#39;\u0026#39; def __init__(self,a,b): \u0026#39;\u0026#39;\u0026#39;公共变量\u0026#39;\u0026#39;\u0026#39; self.a = a self.b = b def add(self): \u0026#39;\u0026#39;\u0026#39;加法\u0026#39;\u0026#39;\u0026#39; return self.a + self.b def sub(self): \u0026#39;\u0026#39;\u0026#39;减法\u0026#39;\u0026#39;\u0026#39; return self.a - self.b # 掠夺者 class Amrc: \u0026#39;\u0026#39;\u0026#39;一台本身只能乘除的计算器，现欲掠夺加减功能\u0026#39;\u0026#39;\u0026#39; def __init__(self,c,d): \u0026#39;\u0026#39;\u0026#39;公共变量\u0026#39;\u0026#39;\u0026#39; self.c = c self.d = d self.cnt = Counter(c,d) # 掠夺 Counter 类的方法 def mul(self): \u0026#39;\u0026#39;\u0026#39;乘法\u0026#39;\u0026#39;\u0026#39; return self.c * self.d def div(self): \u0026#39;\u0026#39;\u0026#39;除法\u0026#39;\u0026#39;\u0026#39; return self.c / self.d 掠夺的本质是，将另一类的实例当作 self 的属性用，这样一来，被掠夺的类的数量就不设上限。此外，假如掠夺者和被掠夺者里都有 add 函数，掠夺者里的方法用 test.add()，被掠夺者里的方法用 test.cnt.add()，于是就不必覆写\n","date":"2025-04-06T18:09:35+08:00","permalink":"https://ZCFZEUS.github.io/p/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A01-python%E5%9F%BA%E7%A1%80/","title":"深度学习（1） Python基础"},{"content":"电阻应变片的种类 常按材料、工作温度范围及用途不同分类\n①按应变片敏感栅的材料分类，可将应变片分成金属应变片和半导体应变片两大类。\n② 按应变片的工作温度分类可分为常温应变片（20℃～60℃）、中温应变片（60℃～300℃）、高温应变片（300℃以上）和低温应变片（低于20℃）等。\n③按应变片的用途分类可分为一般用途应变片和特殊用途应变片（水下、疲劳寿命、抗磁感应、裂缝扩展等）。\n金属电阻应变片 结构 金属电阻应变片简称应变片，其结构大体相同，如图所示。由敏感栅、基底、覆盖层、引线和黏结剂等部分组成。\n敏感栅：实现应变-电阻转换的敏感元件，阻值一般在100Ω以上\n基底：粘贴、定位、绝缘，起着准确将试件应变传递到敏感栅的作用。为此，基底通常很薄，一般为0.02-0.04mm\n覆盖层：用纸或透明胶纸覆盖在敏感栅上，防潮、防尘、防蚀、防损\n引线：起敏感栅与测量电路间的过渡连接和引导作用\n黏结剂：传递应变\n分类 丝式应变片（分回线式和短接式两种） ① 回线式应变片:回线式应变片是将电阻丝绕制成栅粘在绝缘基片上制成的，如图4-2(a)\n特点：制作简单、性能稳定、价格便宜\n② 短接式应变片:短接式应变片是将数根等长的敏感金属丝平行放置，两端用直径比金属丝大5～10倍的镀银丝短接起来而构成的，如图4-2(b)\n优点：克服了回线式应变片的横向效应\n缺点：焊点多，易疲劳损坏\n箔式应变片 箔式应变片是将很薄的金属片粘于基片上，经光刻、腐蚀等制成金属箔敏感栅。给箔敏感栅接上金属丝电极，再涂覆与基片同质料的覆盖层。结构如图4-3所示\n优点：尺寸准确、线条均匀、可按需要做成各种形状、横向效应小、散热好、准确传递、薄、柔、寿命长、稳定性好\n缺点：灵敏度较低\n薄膜应变片 薄膜应变片是薄膜技术发展的产物。它是采用真空蒸发或真空沉积等方法，在薄的绝缘基片上形成厚度在0.1µm下的金属电阻材料薄膜的敏感栅，最后加上保护层。\n优点：应变灵敏系数大，允许电流密度大，工作范围广，温度可达197～371℃\n缺点：难以控制电阻与温度和时间的变化关系\n工作原理 参数 金属电阻应变片的主要参数有：\n（1）应变片电阻值R\n（2）灵敏系数k\n（3）机械滞后Zj\n（4）横向效应及横向效应系数H\n（5）零漂P和蠕变θ\n（6）绝缘电阻Rm\n应变片电阻值R:应变片没有粘贴及未参与变形前，室温下测定的电阻值称为初始电阻值，其中120Ω最常用，应变片电阻值的大小应与测量电阻相配合\n灵敏系数k：衡量应变片质量的重要标志\n机械滞后Zj：实际应用中，由于敏感栅基底和黏结剂材料性能，或者使用过程中的过载、过热，都会使应变计产生残余形变，导致应变片输出的不重合。这种不重合用机械滞后Zj来衡量。它是指粘贴在试件上的应变片，在恒温条件下增（加载）、减（卸载）试件应变的过程中，对应同一机械应变所指示应变量（输出）之差。通常，在室温条件下，要求机械滞后Zj \u0026lt; 3-10με。实测中，可在测试前通过多次重复预加、卸载，来减小机械滞后产生的误差\n横向效应及横向效应系数H\n横向效应：应变片在感受被测试件的应变时，横向应变将使其电阻变化率减小，从而降低灵敏系数，称为应变片的横向效应\n横向效应系数H：垂直时与平行时应变之比\n零漂P和蠕变θ\n零漂：温度恒定、试件初始空载时，应变片电阻值随时间变化的特性。两者之差即为零漂或稳定性误差。可用相对误差或绝对误差表示\n绝缘电阻Rm:略，懒得写了\n温度误差及其补偿 温度误差 温度补偿 单丝自补偿应变片 优点：结构简单，制造、使用方便\n缺点：一种αt值的应变片只能对应在一种材料上应用，局限性大\n双丝自补偿应变片 电桥补偿法 半导体应变片 半导体应变片的分类和结构 按照材料类型分为P型硅应变片、N型硅应变片、PN互补型应变片\n按照特性分为灵敏系数补偿型应变片和非线性补偿应变片\n按照材料的化学成分分为硅、锗、锑化铟、磷化镓、磷化铟等应变片\n目前应用较多的是按照结构分类，包括体型应变片、扩散型应变片和薄膜型半导体应变计\n半导体应变片的工作原理 优点：尺寸、横向效应、机械滞后都很小，灵敏系数极大，因而输出也大，可以不需要放大器直接与记录仪器连接，使得测量系统简化\n缺点：测量较大应变时非线性严重，灵敏系数随受拉或受压而变，且分散度大，一般为3%-5%\n电阻应变片的测量电路 电阻应变片把机械应变信号转换成后，由于应变量及其应变电阻变化一般都很微小，既难以直接精确测量，又不便直接处理，因此，必须采用转换电路或仪器，把应变片的变化转换成电压或电流变化。通常，采用电桥电路实现这种转换。\n直流电桥电路 直流电桥平衡条件 图4-6所示为直流电桥的基本电路，E为电桥电源电压，R1、R2、R3、R4为电桥的桥臂，RL为其负载（可以是测量仪表的内阻或其他负载）。\n电压灵敏度 非线性误差及其补偿方法 提高桥臂比 提高桥臂比可减小非线性误差。但是从电压灵敏度来考虑，提高桥臂比会降低电压灵敏度。因此，为达到既减小非线性误差又不降低电压灵敏度的目的，必须适当提高电源电压E\n采用差动电桥 根据被测试件的受力情况，在同一试件上分别粘贴两个应变片，一个感受拉力，另一个感受压力，两者应变符号相反，测试时，将两个应变片接入电桥的相邻臂上，如图4.7所示，称此电桥电路为半桥差动电路\n优点：差动电桥无非线性误差，而且电压灵敏度为Sv=0.5E,比使用一只应变片提高了1倍，同时可以起到温度补偿的作用\n给电桥的四臂接入4片应变片，使两个桥臂应变片受到拉力，两个桥臂应变片受到压力，将两个应变符号相同的接入相对桥臂上，则构成全桥差动电路。差动桥路的输出电压和电压灵敏度比单片提高了4倍，比半桥差动电路提高了1倍\n采用高内阻的恒流源电桥 产生非线性的原因之一是，在工作过程中通过桥臂的电流不恒定。所以有时用恒流电源供电。如图4-9所示。一般情况下，半导体应变电桥都采用恒流供电，供电电流为 ，通过各臂的电流分别为 和 ，如果测量电路的输入阻抗较高，则I1(R1+R2)=I2(R3+R4),I0=I1+I2,解方程可求得I1和I2\n","date":"2025-04-05T11:55:07+08:00","permalink":"https://ZCFZEUS.github.io/p/%E4%BC%A0%E6%84%9F%E5%99%A84.1-%E5%BA%94%E5%8F%98%E5%BC%8F%E7%94%B5%E9%98%BB%E4%BC%A0%E6%84%9F%E5%99%A8/","title":"传感器4.1 应变式电阻传感器"},{"content":" ","date":"2025-04-04T19:38:27+08:00","permalink":"https://ZCFZEUS.github.io/p/%E4%BC%A0%E6%84%9F%E5%99%A84.2-%E5%8E%8B%E7%94%B5%E5%BC%8F%E5%8A%9B%E4%BC%A0%E6%84%9F%E5%99%A8/","title":"传感器4.2 压电式力传感器"},{"content":"定义 顺序表——用顺序存储的方式实现线性表顺序存储。把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。 1 2 3 4 typedef struct { int num; //号数 int people; //人数 } Customer; 顺序表的实现 静态分配 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdio.h\u0026gt; #define MaxSize 10 //定义最大长度 typedef struct{ ElemType data[MaxSize]; //用静态的“数组”存放数据元素 int length; //顺序表的当前长度 }SqList; //顺序表的类型定义（静态分配方式） //基本操作-初始化一个顺序表 void InitList(SqList\u0026amp;L){ for(int i=0,i\u0026lt;MaxSize;i++) L.data[i] = 0;//将所有数据元素设置为默认值，否则内存中可能会有“脏数据” L.length = 0; } int main(){ SqList L; InitList(L); return 0; } 动态分配 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;stdlib.h\u0026gt; #define InitSize 10 //顺序表的初始长度 typedef struct{ ElemType *data; //指示动态分配数组的指针 int MaxSize; //顺序表的最大容量 int length; //顺序表的当前长度 } SeqList; //顺序表的类型定义（动态分配方式） void InitList(SqList\u0026amp;L){ L.data = (int *)malloc (InitSize*sizeof(int)); L.length = 0; L.MaxSize = InitSize; int main() { SqList L; InitList(L); return 0; } //延长： void IncreaseSize(SeList \u0026amp;L,int len){ int *p = L.data; L.data = (int *)malloc ((L.MaxSize+len)*sizeof(int)); for(int i=0,i\u0026lt;L.length;i++){ L.data[i] = p[i]; } L.MaxaSize += len; free(p);//释放原来内存空间 } } 总结 顺序表的特点：\n①随机访问，即可以在 O(1) 时间内找到第 i 个元素。\n②存储密度高，每个节点只存储数据元素\n③拓展容量不方便（即便采用动态分配的方式实现，拓展长度的时间复杂度也比较高）\n④插入、删除操作不方便，需要移动大量元素 ","date":"2025-04-02T22:47:03+08:00","permalink":"https://ZCFZEUS.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842.2-%E9%A1%BA%E5%BA%8F%E8%A1%A8/","title":"数据结构2.2-顺序表"},{"content":"定义 线性表是具有相同数据类型的n个数据元素的有限序列.\nn为表长，当n = 0时线性表是一个空表.\n若用L命名线性表，则其一般表示为,L = (a1, a2, … , ai, … , an).\n几个概念:\nai是线性表中的“第i个”元素线性表中的位序.\na1是表头元素；an是表尾元素.\n除第一个元素外，每个元素有且仅有一个直接前驱；除最后一个元素外，每个元素有且仅有一个直接后继.\n基本操作 InitList(\u0026amp;L):初始化表。构造一个空的线性表L，分配内存空间。\nDestroyList(\u0026amp;L)：销毁操作。销毁线性表，并释放线性表L所占用的内存空间。\nListInsert(\u0026amp;L,i,e)：插入操作。在表L中的第i个位置上插入指定元素e。\nListDelete(\u0026amp;L,i,\u0026amp;e)：删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。\nLocateElem(L,e)：按值查找操作。在表L中查找具有给定关键字值的元素。\nGetElem(L,i)：按位查找操作。获取表L中第i个位置的元素的值。\nLength(L)：求表长。返回线性表L的长度，即L中数据元素的个数。\nPrintList(L)：输出操作。按前后顺序输出线性表L的所有元素值。\nEmpty(L)：判空操作。若L为空表，则返回true，否则返回false。\n什么时候要传入参数的引用“\u0026amp;” —— 对参数的修改结果需要“带回来”.\n","date":"2025-04-02T22:03:49+08:00","permalink":"https://ZCFZEUS.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842.1-%E7%BA%BF%E6%80%A7%E8%A1%A8/","title":"数据结构2.1-线性表"}]